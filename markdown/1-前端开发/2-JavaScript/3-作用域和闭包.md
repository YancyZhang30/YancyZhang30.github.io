# 作用域

## 一、什么是作用域？
几乎所有编程语言最基本的功能之一，就是能够储存变量当中的值，并且能在之后对这个
值进行访问或修改。事实上，正是这种储存和访问变量的值的能力将状态带给了程序。
若没有了状态这个概念，程序虽然也能够执行一些简单的任务，但它会受到高度限制，做
不到非常有趣。

### 1.1 编译原理
尽管通常将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。

尽管如此，JavaScript 引擎进行编译的步骤和传统的编译语言非常相似，在某些环节可能
比预想的要复杂。

在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编
译”。
- 分词/词法分析（Tokenizing/Lexing）:
这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代
码块被称为词法单元（token）。例如，考虑程序 var a = 2;。这段程序通常会被分解成
为下面这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在
这门语言中是否具有意义。

- 解析/语法分析（Parsing）:
这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法
结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。
var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下
来是一个叫作 Identifier（它的值是 a）的子节点，以及一个叫作 AssignmentExpression
的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral（它的值是 2）的子
节点。

- 代码生成:
将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息
息相关。
抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指
令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。

比起那些编译过程只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。

对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。
在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法（比如 JIT，可以延
迟编译甚至实施重编译）来保证性能最佳。

简单地说，任何 JavaScript 代码片段在**执行前都要进行编译（通常就在执行前）**。因此，JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。
### 1.2 理解编译原理

#### 引擎
从头到尾负责整个 JavaScript 程序的编译及执行过程。

#### 编译器
引擎的好朋友之一，负责语法分析及代码生成等脏活累活。

#### 作用域
引擎的另一位好朋友，负责收集并维护由所有声明的标识符（变量）组成的一系列查
询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如
果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对
它赋值。

LHS查询、RHS查询。

RHS 查询与简单地查找某个变量的值别无二致，而 LHS 查询则是试图
找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS 并不是真正意义上的“赋
值操作的右侧”，更准确地说是“非左侧”。
你可以将 RHS 理解成 retrieve his source value（取到它的源值），这意味着“得到某某的
值”。
### 1.3 作用域嵌套
作用域是根据名称查找变量的一套规则。实际情况中，通常需要同时顾及几个
作用域。

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用
域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，
或抵达最外层的作用域（也就是**全局作用域**）为止。

遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，
就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都
会停止。

```js
function foo(a) {
console.log( a + b );
b = a;
}
foo( 2 );
```
第一次对 b 进行 RHS 查询时是无法找到该变量的。也就是说，这是一个“未声明”的变
量，因为在任何相关的作用域中都无法找到它。

如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError
异常。值得注意的是，ReferenceError 是非常重要的异常类型。

相较之下，当引擎执行 LHS 查询时，如果在顶层（全局作用域）中也无法找到目标变量，
全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非
“**严格模式**”下。

ES5 中引入了“严格模式”。同正常模式，或者说宽松 / 懒惰模式相比，严格模式在行为上
有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在
严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询
失败时类似的 ReferenceError 异常。

接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，
比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的
属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。

ReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对
结果的操作是非法或不合理的。

### 1.4 小结
作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。

赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域
的赋值操作。

JavaScript 引擎首先会在代码执行前对其进行编译，在这个过程中，像 var a = 2 这样的声
明会被分解成两个独立的步骤：
1. 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。
2. 接下来，a = 2 会查询（LHS 查询）变量 a 并对其进行赋值。

LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所
需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层
楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。

不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式
地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛
出 ReferenceError 异常（严格模式下）。

## 二、词法作用域
作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法
作用域，我们会对这种作用域进行深入讨论。另外一种叫作动态作用域，仍有一些编程语
言在使用（比如 Bash 脚本、Perl 中的一些模式等）

### 2.1 词法阶段

### 2.2 欺骗语法
如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修
改”（也可以说欺骗）词法作用域呢？

#### 2.2.1 eval
JavaScript 中的 `eval(..)` 函数可以接受一个字符串为参数，并将其中的内容视为好像在书
写时就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并
运行，就好像代码是写在那个位置的一样。
```js
function foo(str, a) {
eval( str ); // 欺骗！
console.log( a, b );
}
var b = 2;
foo( "var b = 3;", 1 ); // 1, 3
```
eval(..) 调用中的 "var b = 3;" 这段代码会被当作本来就在那里一样来处理。由于那段代
码声明了一个新的变量 b，因此它对已经存在的 foo(..) 的词法作用域进行了修改。事实
上，和前面提到的原理一样，这段代码实际上在 foo(..) 内部创建了一个变量 b，并**遮蔽**
了外部（全局）作用域中的同名变量。
#### 2.2.2 with
JavaScript 中另一个难以掌握（并且现在也不推荐使用）的用来欺骗词法作用域的功能是
with 关键字。

with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象
本身。

```js
var obj = {
a: 1,
b: 2,
c: 3
};
// 单调乏味的重复 "obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;
```

```js
// 简单的快捷方式
with (obj) {
a = 3;
b = 4;
c = 5;
}
```
## 三、函数作用域和块作用域

### 3.1 函数作用域
函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复
用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用
JavaScript 变量可以根据需要改变值类型的“动态”特性。

```js
function doSomething(a) {
  b = a + doSomethingElse( a * 2 );
  console.log( b * 3 );
}

function doSomethingElse(a) {
  return a - 1;
}

var b;

doSomething( 2 ); // 15
```
在这个代码片段中，变量 b 和函数 doSomethingElse(..) 应该是 doSomething(..) 内部具体
实现的“私有”内容。给予外部作用域对 b 和 doSomethingElse(..) 的“访问权限”不仅
没有必要，而且可能是“危险”的，因为它们可能被有意或无意地以非预期的方式使用，
从而导致超出了 doSomething(..) 的适用条件。更“合理”的设计会将这些私有的具体内
容隐藏在 doSomething(..) 内部。
改进：
```js
function doSomething(a) {
  function doSomethingElse(a) {
    return a - 1;
  }
  var b;
  b = a + doSomethingElse( a * 2 );
  console.log( b * 3 );
}
doSomething( 2 ); // 15
```
### 3.2 块级作用域
尽管函数作用域是最常见的作用域单元，当然也是现行大多数 JavaScript 中最普遍的设计
方法，但其他类型的作用域单元也是存在的，并且通过使用其他类型的作用域单元甚至可
以实现维护起来更加优秀、简洁的代码。

#### 3.2.1 let
let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说，let
为其声明的变量隐式地了所在的块作用域。
```js
for (let i=0; i<10; i++) {
  console.log( i );
}
console.log( i ); // ReferenceError
```
for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环
的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。

#### 3.2.2 const
除了 let 以外，ES6 还引入了 const，同样可以用来创建块作用域变量，但其值是固定的
（常量）。之后任何试图修改值的操作都会引起错误。
```js
var foo = true;
if (foo) {
  var a = 2;
  const b = 3; // 包含在 if 中的块作用域常量
  a = 3; // 正常 !
  b = 4; // 错误 !
}
console.log( a ); // 3
console.log( b ); // ReferenceError!
```

## 四、提升

### 4.1 变量提升
直觉上会认为 JavaScript 代码在执行时是**由上到下一行一行**执行的。但实际上这并不完全
正确，有一种特殊情况会导致这个假设是错误的。
```js
a = 2;
var a;
console.log( a );//2
```

```js
console.log( a );
var a = 2; // undefined
```
当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个
声明：`var a; `和 `a = 2;`。

第一个定义声明是在编译阶段进行的。第二个赋值声明会被留在原地等待执行阶段。

因此，打个比方，这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动”
到了最上面。这个过程就叫作`提升`。

:::tip
只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。
:::

### 4.2 函数提升
```js
foo();
function foo() {
  console.log( a ); // undefined
  var a = 2;
}
```
foo 函数的声明（这个例子还包括实际函数的隐含值）被提升了，因此第一行中的调用可以正常执行。

另外值得注意的是，**每个作用域**都会进行提升操作。
尽管前面大部分的代码片段已经简化了（因为它们只包含全局作用域），而我们正在讨论的 foo(..) 函数自身也会在内部对 var
a 进行提升（显然并不是提升到了整个程序的最上方，而是函数作用域内）。

我们可以理解为：
```js
function foo() {
  var a;
  console.log( a ); // undefined
  a = 2;
}

foo();
```
可以看到，函数声明会被提升，但是函数表达式却不会被提升。

```js
foo(); // 不是 ReferenceError, 而是 TypeError!
var foo = function bar() {
  // ...
};
```

### 4.3 函数优先
函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是**函数会首先被提升**，然后才是变量。

```js
foo(); // 1

var foo;

function foo() {
  console.log( 1 );
}

foo = function() {
  console.log( 2 );
};

foo(); //2
```

会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式：
```js
function foo() {
  console.log( 1 );
}

foo(); // 1

foo = function() {
  console.log( 2 );
};

foo(); //2
```
注意，var foo 尽管出现在 function foo()... 的声明之前，但它是重复的声明（因此被忽略了），因为**函数声明会被提升到普通变量之前**。

尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。

## 五、闭包
闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。
闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。

```js
function foo() {
  var a = 2;

  function bar() {
    console.log( a );
  }

  bar();
}

foo(); // 2
```
这段代码看起来和嵌套作用域中的示例代码很相似。基于词法作用域的查找规则，函数bar() 可以访问外部作用域中的变量 a（这个例子中的是一个 RHS 引用查询）。

技术上来讲，也许是。但根据前面的定义，确切地说并不是。我认为最准确地用来解释**bar() 对 a 的引用的方法是词法作用域的查找规则**，而这些规则只是闭包的一部分。（但却是非常重要的一部分！）

从纯学术的角度说，在上面的代码片段中，函数 bar() 具有一个涵盖 foo() 作用域的闭包（事实上，涵盖了它能访问的**所有作用域**，比如全局作用域）。也可以认为 bar() 被封闭在了 foo() 的作用域中。为什么呢？原因简单明了，因为 bar() 嵌套在 foo() 内部。

```js
function foo() {
  var a = 2;

  function bar() {
    console.log( a );
  }

  return bar;
}

var baz = foo();

baz(); // 2 —— 朋友，这就是闭包的效果。
```
函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。

在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有**垃圾回收器**用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。

而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上**内部作用域**依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 **bar() **本身在使用。

:::tip
无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。
:::

```js
for (var i=1; i<=5; i++) {
  setTimeout( function timer() {
    console.log( i );
  }, i*1000 );
}
```
正常情况下，我们对这段代码行为的预期是分别输出数字 1~5，每秒一次，每次一个。

但实际上，这段代码在运行时会以每秒一次的频率输出五次 6。

首先解释 6 是从哪里来的。这个循环的终止条件是 i 不再 <=5。条件首次成立时 i 的值是
6。因此，输出显示的是循环结束时 i 的最终值。

仔细想一下，这好像又是显而易见的，延迟函数的回调会在循环结束时才执行。事实上，
当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)，所有的回调函数依然是在循
环结束后才会被执行，因此会每次输出一个 6 出来。

缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是
根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，
但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。

这样说的话，当然所有函数共享一个 i 的引用。

使用IIFE:
```js
for (var i=1; i<=5; i++) {
  (function(j) {
    setTimeout( function timer() {
    console.log( j );
    }, j*1000 );
  })( i );
}
```
块级作用域：
```js
for (let i=1; i<=5; i++) {
  setTimeout( function timer() {
    console.log( i );
  }, i*1000 );
}
```