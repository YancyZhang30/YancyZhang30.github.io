
## 浮动
虽然最初创造浮动并不是为了用于页面布局，但它在布局方面表现得很出色。然而为了理解浮动，我们首先必须牢记它的设计初衷。

浮动能将一个元素（通常是一张图片）拉到其容器的一侧，这样文档流就能够包围它。这种布局在报纸和杂志中很常见，因此CSS增加了浮动来实现这种效果。

![浮动布局](https://res.weread.qq.com/wrepub/epub_31594821_145)

一个元素被拉到了左侧，它也可以浮动到右侧。浮动元素会被移出正常文档流，并被拉到容器边缘。
文档流会重新排列，但是它会包围浮动元素此刻所占据的空间。如果让多个元素向`同侧浮动`，它们就会挨着排列。

![浮动布局2](https://res.weread.qq.com/wrepub/epub_31594821_146)

### 容器折叠/高度塌陷

![高度塌陷](https://res.weread.qq.com/wrepub/epub_31594821_153)

白色的背景区域是怎么回事？白色背景的确出现在了页面标题（“Running tips”）后面，但是并没有向下延伸，直到包含媒体盒子。

这是因为浮动元素不同于普通文档流的元素，它们的高度不会加到父元素上。这可能看起来很奇怪，但是恰好体现了浮动的设计初衷。

解决办法：
1. 用clear属性清除浮动
clear: both声明让该元素移动到浮动元素的下面，而不是侧面。clear的值还可以设置为left或者right，这样只会相应地清除向左或者向右浮动的元素。因为空div本身没有浮动，所以容器就会扩展，直到包含它，因此也会包含该div上面的浮动元素。

2. 伪元素
![伪元素](https://res.weread.qq.com/wrepub/epub_31594821_159)


## BFC
块级格式化上下文（block formatting context, BFC）。BFC是网页的一块区域，元素基于这块区域布局。虽然BFC本身是环绕文档流的一部分，但它将内部的内容与外部的上下文隔离开。这种隔离为创建BFC的元素做出了以下3件事情。

(1) 包含了内部所有元素的上下外边距。它们不 会跟BFC外面的元素产生`外边距折叠`。

(2) `包含了内部所有`的浮动元素。

(3) 不会跟BFC外面的浮动元素`重叠`。

简而言之，BFC里的内容不会跟外部的元素重叠或者相互影响。如果给元素增加clear属性，它只会清除自身所在BFC内的浮动。如果强制给一个元素生成一个新的BFC，它不会跟其他BFC重叠。

给元素添加以下的任意属性值都会创建BFC。

❑ float: left或right，不为none即可。

❑ overflow:hidden、auto或scroll，`不为visible`即可。

❑ display:inline-block、table-cell、table-caption、flex、inline-flex、grid或inline-grid。拥有这些属性的元素称为块级容器（block container）。

❑ position:absolute或position: fixed。

> 说明：网页的根元素html也创建了一个顶级的BFC。


## 网格系统

![网格](https://res.weread.qq.com/wrepub/epub_31594821_173)

选取12作为列数是因为它能够被2、3、4、6整除，组合起来足够灵活。比如可以很容易地实现一个3列布局（3个4列宽的元素）或者一个4列布局（4个3列宽的元素）。还可以实现非对称的布局，比如一个9列宽的主元素和一个3列宽的侧边栏。在每个子元素里可以放置任意标记。

![构建](https://res.weread.qq.com/wrepub/epub_31594821_177)

常见组件库的栅格组件，应该也是这个思想。

## FlexBox
Flexbox，全称弹性盒子布局（Flexible Box Layout），是一种新的布局方式。跟浮动布局相比，Flexbox的可预测性更好，还能提供更精细的控制。它也能轻松解决困扰我们许久的垂直居中和等高列问题。


一切要从我们熟悉的display属性开始。给元素添加display: flex，该元素变成了一个弹性容器（flex container），它的直接子元素变成了弹性子元素（flex item）。

弹性子元素默认是在同一行按照从左到右的顺序并排排列。弹性容器像块元素一样`填满可用宽度`，但是弹性子元素不一定填满其弹性容器的宽度。弹性子元素高度相等，该高度由它们的`内容决定`。

> 还可以用display: inline-flex。它创建了一个弹性容器，行为类似于inline-block元素。它会跟其他行内元素一起流式排列，但`不会自动增长到100%的宽度`。内部的弹性子元素跟使用display:flex创建的Flexbox里的弹性子元素行为一致。

之前提到的display值，比如inline、inline-block等，只会影响到应用了该样式的元素，而Flexbox则不一样。一个弹性容器能控制内部元素的布局。

![flexbox](https://res.weread.qq.com/wrepub/epub_31594821_190)

子元素按照主轴线排列，主轴的方向为主起点（左）到主终点（右）。垂直于主轴的是副轴。方向从副起点（上）到副终点（下）。

### 子元素flex属性

flex属性控制弹性子元素在主轴方向上的大小（在这里指的元素的宽度）。

flex属性是三个不同大小属性的简写：`flex-grow`、`flex-shrink`和`flex-basis`。ru如果只提供了flex-grow的值（第一个参数），剩下的两个属性是`默认值`（分别是1和0%），因此flex: 2等价于flex: 210%。

通常首选简写属性，但也可以分别声明三个属性。

flex-basis定义了元素大小的基准值，即一个初始的“主尺寸”。flex-basis属性可以设置为任意的width值，包括px、em、百分比。它的`初始值是auto`，此时浏览器会检查元素是否设置了width属性值。如果有，则使用width的值作为flex-basis的值；如果没有，`则用元素内容自身的大小`。

每个弹性子元素的`flex-basis值计算出来后`，它们（加上子元素之间的外边距）加起来会占据一定的宽度。加起来的宽度不一定正好填满弹性容器的宽度，可能会有留白。

多出来的留白（或剩余宽度）会按照flex-grow（增长因子）的值分配给每个弹性子元素，flex-grow的值为非负整数。如果一个弹性子元素的`flex-grow值为0`，那么它的宽度`不会超过flex-basis的值`；如果某个弹性子元素的`增长因子非0`，那么这些元素会增长到所有的剩余空间被分配完，也就意味着弹性子元素会填满容器的宽度。

flex-grow的值越大，元素的“权重”越高，也就会占据更大的剩余宽度。一个flex-grow:2的子元素增长的宽度为flex-grow: 1的子元素的两倍。

还记得前面的三个板块吗？简写声明flex: 2和flex: 1设置了一个弹性基准值为0%，因此容器宽度的100%都是剩余宽度（减去两列之间1.5em的外边距）。

![flex](  https://res.weread.qq.com/wrepub/epub_31594821_207)

flex-shrink属性与flex-grow遵循相似的原则，根据flex-basis计算出弹性子元素的初始主尺寸后，它们的累加值可能会`超出弹性容器的可用宽度`。如果不用flex-shrink，就会导致溢出。

每个子元素的flex-shrink值代表了它是否应该收缩以防止溢出。如果某个子元素为flex-shrink: 0，则不会收缩；如果值大于0，则会收缩至不再溢出。按照flex-shrink值的比例，值越大的元素收缩得越多。

- `<'flex-grow'>`
定义 flex 项目的 flex-grow 。负值无效。省略时默认值为 1。 (初始值为 0)

- `<'flex-shrink'>`
定义 flex 元素的 flex-shrink 。负值无效。省略时默认值为1。 (初始值为 1)

- `<'flex-basis'>`
定义 flex 元素的 flex-basis 属性。若值为0，则必须加上单位，以免被视作伸缩性。省略时默认值为 0。(初始值为 auto)

> 即如果没有设置flex属性，那么默认值就是`flex: 0 1 auto`。如果设置了flex属性（可能有1、2、3个参数），那么默认值就是`flex: 1 1 auto`。

### flex-direction
Flexbox的另一个重要功能是能够切换主副轴方向，用弹性容器的flex-direction属性控制。如前面的例子所示，它的初始值（row）控制子元素按从左到右的方向排列；指定flex-direction: column能控制弹性子元素沿垂直方向排列（从上到下）。Flexbox还支持row-reverse让元素从右到左排列，column-reverse让元素从下到上排列。

### 容器属性
flex-wrap属性允许弹性子元素换到新的一行或多行显示。它可以设置为nowrap（初始值）、wrap或者wrap-reverse。启用换行后，子元素不再根据flex-shrink值收缩，任何超过弹性容器的子元素都会换行显示。

flex-flow属性是flex-direction和flex-wrap的简写。例如，flex-flow:column wrap指定弹性子元素按照从上到下的方式排列，必要时换到新的一列。

当子元素未填满容器时，justify-content属性控制子元素沿主轴方向的间距。它的值包括几个关键字：flex-start、flex-end、center、space-between以及space-around。默认值flex-start让子元素从主轴的开始位置顺序排列，比如主轴方向为从左到右的话，开始位置就是左边。如果不设置外边距，那么子元素之间不会产生间距。如果值为flex-end，子元素就从主轴的结束位置开始排列，center的话则让子元素居中。

justify-content控制子元素在主轴方向的对齐方式，align-items则控制子元素在副轴方向的对齐方式。align-items的初始值为stretch，在水平排列的情况下让所有子元素填充容器的高度，在垂直排列的情况下让子元素填充容器的宽度，因此它能实现等高列。

如果开启了换行（用flex-wrap）, align-content属性就可以控制弹性容器内沿副轴方向每行之间的间距。它支持的值有flex-start、flex-end、center、stretch（初始值）、space-between以及space-around。这些值对间距的处理类似上面的justify-content。

### 子元素属性

align-items属性控制弹性子元素沿着容器副轴方向的对齐方式。它跟弹性容器的align-items属性效果相同，但是它能单独给弹性子元素设定不同的对齐方式。auto为初始值，会以容器的align-items值为准。其他值会覆盖容器的设置。align-self属性支持的关键字与align-items一样：flex-start、flex-end、center、stretch以及baseline。

正常情况下，弹性子元素按照在HTML源码中出现的顺序排列。它们沿着主轴方向，从主轴的起点开始排列。使用order属性能改变子元素排列的顺序。还可以将其指定为任意正负整数。如果多个弹性子元素有一样的值，它们就会按照源码顺序出现。

初始状态下，所有的弹性子元素的order都为0。指定一个元素的值为−1，它会移动到列表的最前面；指定为1，则会移动到最后。可以按照需要给每个子元素指定order以便重新编排它们。这些值不一定要连续。

## 网格布局Grid
CSS网格可以定义由行和列组成的二维布局，然后将元素放置到网格中。有些元素可能只占据网格的一个单元，另一些元素则可能占据多行或多列。网格的大小既可以精确定义，也可以根据自身内容自动计算。你既可以将元素精确地放置到网格某个位置，也可以让其在网格内自动定位，填充划分好的区域。

![grid](https://res.weread.qq.com/wrepub/epub_31594821_224)


跟Flexbox类似，网格布局也是作用于两级的DOM结构。设置为display: grid的元素成为一个网格容器（grid container）。它的子元素则变成网格元素（grid items）。

![grid](https://res.weread.qq.com/wrepub/epub_31594821_227)


接下来是新属性：grid-template-columns和grid-template-rows。

这两个属性定义了网格每行每列的大小。本例使用了一种`新单位fr`，代表每一列（或每一行）的分数单位`（fraction unit）`。这个单位跟Flexbox中`flex-grow因子`的表现一样。grid-template-columns:1fr 1fr 1fr表示`三列等宽`。

不一定非得用分数单位，可以使用其他的单位，比如px、em或百分数。也可以混搭这几种单位，例如，grid-template-columns:300px 1fr定义了一个固定宽度为300px的列，后面跟着一个会填满剩余可用空间的列。2fr的列宽是1fr的两倍。

最后，grid-gap属性定义了每个网格单元之间的间距。也可以用两个值分别指定垂直和水平方向的间距（比如grid-gap: 0.5em 1em）。

### 网格刨析


![grid](https://res.weread.qq.com/wrepub/epub_31594821_228)

❑ 网格线（grid line）—— 网格线构成了网格的框架。一条网格线可以水平或垂直，也可以位于一行或一列的任意一侧。如果指定了grid-gap的话，它就位于网格线上。

❑ 网格轨道（grid track）—— 一个网格轨道是两条相邻网格线之间的空间。网格有水平轨道（行）和垂直轨道（列）。

❑ 网格单元（grid cell）—— 网格上的单个空间，水平和垂直的网格轨道交叉重叠的部分。

❑ 网格区域（grid area）—— 网格上的矩形区域，由一个到多个网格单元组成。该区域位于两条垂直网格线和两条水平网格线之间。


构建网格布局时会涉及这些组成部分。比如声明grid-template-columns: 1fr 1fr 1fr就会定义三个等宽且垂直的网格轨道，同时还定义了四条垂直的网格线：一条在网格最左边，两条在每个网格轨道之间，还有一条在最右边。

![grid](https://res.weread.qq.com/wrepub/epub_31594821_232)

代码首先设置了网格容器，并用`grid-template-columns`和`grid-template-rows`定义了网格轨道。因为列的分数单位分别是2fr和1fr，所以第一列的宽度是第二列的两倍。

定义行的时候用到了一个新方法：repeat()函数。它在声明多个网格轨道的时候提供了简写方式。grid-template-rows: repeat(4, auto)；定义了四个`水平网格轨道`，高度为auto，这等价于grid-template-rows: auto auto auto auto。轨道大小设置为auto，轨道会根据`自身内容扩展`。

### 网格编号

网格轨道定义好之后，要将每个网格元素放到特定的位置上。浏览器给网格里的每个网格线都赋予了编号，如图所示。CSS用这些编号指出每个元素应该摆放的位置。

![网格编号](https://res.weread.qq.com/wrepub/epub_31594821_234)

可以在grid-column和grid-row属性中用网格线的编号指定`网格元素`的位置。如果想要一个网格元素在`垂直方向上跨越1号网格线到3号网格线`，就需要给元素设置grid-column: 1 / 3。或者设置grid-row: 3 / 5让元素在`水平方向上跨越3号网格线到5号网格线`。

![网格编号](https://res.weread.qq.com/wrepub/epub_31594821_235)

这段代码将main元素放在第一列（1号到2号网格线之间），跨越第三行到第四行（3号到5号网格线）的位置。侧边栏的两个板块放在右列（2号到3号网格线之间），并且在第三行和第四行上下排列。


> 这些属性实际上是简写属性：grid-column是grid-column-start和grid-column-end的简写；grid-row是grid-row-start和grid-row-end的简写。中间的斜线只在简写属性里用于区分两个值，斜线前后的空格不作要求。


### 与FlexBox配合

❑ Flexbox本质上是一维的，而网格是二维的。

❑ Flexbox是以内容为切入点由内向外工作的，而网格是以布局为切入点从外向内工作的。

因为Flexbox是一维的，所以它很适合用在相似的元素组成的行（或列）上。它支持用flex-wrap换行，但是没法让上一行元素跟下一行元素对齐。相反，网格是二维的，旨在解决一个轨道的元素跟另一个轨道的元素对齐的问题。

![FlexBox](https://res.weread.qq.com/wrepub/epub_31594821_237)

### 替代语法

布局网格元素还有另外两个替代语法：命名的网格线和命名的网格区域。

有时候记录所有网格线的编号实在太麻烦了，尤其是在处理很多网格轨道时。为了能简单点，可以给`网格线命名`，并在布局时使用`网格线的名称`而不是编号。声明网格轨道时，可以在中括号内写上网格线的名称，如下代码片段所示。

#### 命名网格线
![命名的网格线](  https://res.weread.qq.com/wrepub/epub_31594821_242)

这条声明定义了两列的网格，三条垂直的网格线分别叫作start、center和end。之后定义网格元素在网格中的位置时，可以不用编号而是用这些名称来声明。

![命名的网格线](  https://res.weread.qq.com/wrepub/epub_31594821_243)

还可以给同一个网格线提供多个名称，比如下面的声明（为了可读性，这里将代码换行了）。

![命名的网格线](  https://res.weread.qq.com/wrepub/epub_31594821_244)

在这条声明里，2号网格线既叫作left-end也叫作right-start，之后可以任选一个名称使用。这里还有一个彩蛋：将网格线命名为left-start和left-end，就定义了一个叫作`left的区域`，这个区域覆盖两个网格线之间的区域。-start和-end后缀作为`关键字`，定义了两者之间的区域。如果给元素设置`grid-column: left`，它就会跨越从`left-start到left-end`的区域。

![命名的网格线](  https://res.weread.qq.com/wrepub/epub_31594821_245)

#### 命名网格区域
另一个方式是`命名网格区域`。不用计算或者命名网格线，直接用命名的网格区域将元素定位到网格中。实现这一方法需要借助网格容器的grid-template-areas性和网格元素的grid-area属性。

![命名的网格区域](  https://res.weread.qq.com/wrepub/epub_31594821_247)

grid-template-areas属性使用了一种ASCIIart的语法，可以直接在CSS中画一个可视化的网格形象。该声明给出了一系列加引号字符串，每一个字符串代表网格的一行，字符串内用空格区分每一列。

>  警告: 每个命名的网格区域必须组成一个矩形。不能创造更复杂的形状，比如L或者U型。

还可以用句点（.）作为名称，这样便能空出一个网格单元。比如，以下代码定义了四个网格区域，中间围绕着一个空的网格单元。

![命名的网格区域](  https://res.weread.qq.com/wrepub/epub_31594821_248)


网格布局共设计了三种语法：编号的网格线、命名的网格线、命名的网格区域。最后一个可能更受广大开发人员喜爱，尤其是明确知道每个网格元素的位置时，这种方式用起来更舒服。

### 显式和隐式网格

在某些场景下，你可能不清楚该把元素放在网格的哪个位置上。当处理大量的网格元素时，挨个指定元素的位置未免太不方便。当元素是从数据库获取时，元素的个数可能是未知的。在这些情况下，以一种宽松的方式定义网格可能更合理，剩下的交给布局算法来放置网格元素。

这时需要用到隐式网格（implicit grid）。使用grid-template-＊属性定义网格轨道时，创建的是显式网格（explicit grid），但是有些网格元素仍然可以放在显式轨道外面，此时会`自动创建隐式轨道以扩展网格`，从而包含这些元素。

![隐式网格](https://res.weread.qq.com/wrepub/epub_31594821_249)

隐式网格轨道默认大小为auto，也就是它们会扩展到能容纳网格元素内容。可以给网格容器设置grid-auto-columns和grid-auto-rows，为隐式网格轨道指定一个大小（比如，grid-auto-columns: 1fr）。

> 在指定网格线的时候，隐式网格轨道不会改变负数的含义。负的网格线编号仍然是从显式网格的右下开始的。

![隐式网格](https://res.weread.qq.com/wrepub/epub_31594821_253)

网格布局模块规范提供了另一个属性grid-auto-flow，它可以控制布局算法的行为。它的初始值是row，上一段描述的就是这个值的行为。如果值为column，它就会将元素优先放在网格列中，只有当一列填满了，才会移动到下一行。

还可以额外加一个关键字dense（比如，grid-auto-flow: column dense）。它让算法紧凑地填满网格里的空白，尽管这会改变某些网格元素的顺序。加上这个关键字，小元素就会“回填”大元素造成的空白区域

### 特性查询

CSS最近添加了一个叫作特性查询（featurequery）的功能，该功能有助于解决这个问题，如下代码片段所示。

![隐式网格](https://res.weread.qq.com/wrepub/epub_31594821_262)

@supports规则后面跟着一个小括号包围的声明。如果浏览器理解这个声明（在本例中，浏览器支持网格），它就会使用大括号里面的所有样式规则。如果它不理解小括号里的声明，就不会使用这些样式规则。

### 对齐

CSS给网格布局提供了三个调整属性：justify-content、justify-items、justify-self。这些属性控制了网格元素在水平方向上的位置。我是这样记的：就像在文字处理器里调整文字位置，让它们在水平方向上分布。

还有三个对齐属性：align-content、align-items、align-self。这些属性控制网格元素在垂直方向上的位置。我是这样记的：就像表格布局里的vertical-align属性。

![对齐](https://res.weread.qq.com/wrepub/epub_31594821_266)

可以用justify-content和align-content设置网格容器内的网格轨道在水平方向和垂直方向上的位置，特别是当网格元素的大小无法填满网格容器时。参考以下代码。

![对齐](https://res.weread.qq.com/wrepub/epub_31594821_267)

（Flexbox里则是flex-end）。

❑ center——将网格轨道放在网格容器的中间。

❑ stretch——将网格轨道拉伸至填满网格容器。

❑ space-between——将剩余空间平均分配到每个网格轨道之间（它能覆盖任何grid-gap值）。

❑ space-around——将空间分配到每个网格轨道之间，且在两端各加上一半的间距。

❑ space-evenly——将空间分配到每个网格轨道之间，且在两端各加上同等大小的间距（Flexbox规范不支持）。


## 定位和层叠上下文

### 定位position
position属性。它可以用来构建下拉菜单、模态框以及现代Web应用程序的一些基本效果。定位可能变得很复杂。许多开发人员对它只有粗略的理解。如果不完全了解定位以及它可能带来的后果，就很容易给自己挖坑。有时候你可能会把错误的元素放在其他元素前面，要解决这个问题却没有那么简单。

position属性的初始值是**static**。

如果把它改成其他值，我们就说元素就**被定位了**。而如果元素使用了静态定位，那么就说它未被定位。

#### 固定定位fixed
固定定位不如其他定位类型用得普遍，但它是最好理解的一种定位类型，因此我先从它开始介绍。给一个元素设置position: fixed就能将元素放在视口的任意位置。这需要搭配四种属性一起使用：top、right、bottom和left。这些属性的值决定了固定定位的元素与浏览器视口边缘的距离。比如，top: 3em表示元素的上边缘距离视口顶部3em。

设置这四个值还隐式地定义了`元素的宽高`。比如指定left: 2em; right: 2em表示元素的左边缘距离视口左边2em，右边缘距离视口右边2em。因此元素的宽度等于视口总宽度减去4em。top、bottom和视口高度也是这样的关系。

定位一个元素时，不要求指定四个方向的值，可以只指定需要的方向值，然后用width和/或height来决定它的大小，也可以让元素本身来决定大小。

![定位](https://res.weread.qq.com/wrepub/epub_31594821_271)

#### 绝对定位absolute

![绝对定位](https://res.weread.qq.com/wrepub/epub_31594821_273)

> 如果祖先元素都没有定位，那么绝对定位的元素会基于初始包含块（initialcontaining block）来定位。初始包含块跟视口一样大，固定在网页的顶部。

#### 相对定位relative

相对定位可能是最不被理解的定位类型。当第一次给元素加上position: relative的时候，你通常看不到页面上有任何视觉改变。相对定位的元素以及它周围的所有元素，都还保持着原来的位置（尽管你可能会看到某些元素跑到另一些元素前面，我后面会解释这个问题）。

如果加上top、right、bottom和left属性，元素就会从原来的位置移走，但是不会改变它周围任何元素的位置。如图7-4所示，四个inline-block元素，给第二个元素加上三个额外的属性：position: relative、top: 1em、left: 2em，将其从初始位置移走，但是其他元素没有受到影响。它们还是围绕着被移走元素的初始位置，跟随着正常的文档流。

![相对定位](https://res.weread.qq.com/wrepub/epub_31594821_276)

> 跟固定或者绝对定位不一样，不能用top、right、bottom和left改变相对定位元素的大小。这些值只能让元素在上、下、左、右方向移动。可以用top或者bottom，但它们不能一起用（bottom会被忽略）。同理，可以用left或right，但它们也不能一起用（right会被忽略）。

#### 粘性定位sticky
粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。

```css
#one {
  position: sticky;
  top: 10px;
}
```

在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。

须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。

注意，一个 sticky 元素会“固定”在离它最近的一个拥有`“滚动机制”`的祖先上（当该祖先的 overflow 是 hidden、scroll、auto 或 overlay 时），即便这个祖先不是最近的真实可滚动祖先。
### 层叠上下文和z-index

浏览器将HTML解析为DOM的同时还创建了另一个树形结构，叫作渲染树（render tree）。它代表了每个元素的视觉样式和位置。同时还决定浏览器绘制元素的顺序。

顺序很重要，因为如果元素刚好重叠，后绘制的元素就会出现在先绘制的元素前面。

```html
<div>one</div>
<div>two</div>
<div>three</div>
```

![层叠上下文](https://res.weread.qq.com/wrepub/epub_31594821_287)

定位元素时，这种行为会改变。浏览器会先绘制所有`非定位的元素`，然后绘制定位元素。默认情况下，所有的定位元素会出现在非定位元素`前面`。

给前两个元素加了position: relative，它们就绘制到了前面，覆盖了静态定位的第三个元素，尽管元素在HTML里的顺序并未改变。

![层叠上下文](https://res.weread.qq.com/wrepub/epub_31594821_288)

#### 使用z-index控制层叠顺序
z-index属性的值可以是任意整数（正负都行）。z表示的是笛卡儿x-y-z坐标系里的`深度方向`。拥有较高z-index的元素出现在拥有较低z-index的元素前面。拥有负数z-index的元素出现在静态元素后面。

z-index的行为很好理解，但是使用它时要注意两个小陷阱。

- 第一，z-index`只在定位元素上生效`，`不能`用它控制静态元素。

- 第二，给一个定位元素加上z-index可以`创建层叠上下文`。

#### 理解层叠上下文

一个层叠上下文包含一个元素或者由浏览器一起绘制的一组元素。其中一个元素会作为层叠上下文的根，比如给一个定位元素加上z-index的时候，它就变成了一个`新的层叠上下文的根`。所有后代元素就是这个层叠上下文的`一部分`。

不要将层叠上下文跟第4章的BFC弄混了，它们是两个独立的概念，尽管不一定互斥。层叠上下文负责决定哪些元素出现在另一些元素前面，而BFC负责处理文档流，以及元素是否会重叠。

实际上将层叠上下文里的所有元素一起绘制会造成严重的后果：层叠上下文之外的元素无法叠放在层叠上下文内的两个元素之间。换句话说，如果一个元素叠放在一个层叠上下文前面，那么层叠上下文里没有元素可以被拉到该元素前面。同理，如果一个元素被放在层叠上下文后面，层叠上下文里没有元素能出现在该元素后面。

这段代码包含了三个盒子，其中两个被定位，并且z-index为1，第一个盒子里面有一个绝对定位的元素，它的z-index为100。虽然第一个盒子的z-index很高，但还是出现在第二个盒子后面，因为它的父元素，即第一个盒子形成的层叠上下文在第二个盒子后面。

![z-index](https://res.weread.qq.com/wrepub/epub_31594821_290)

![z-index](https://res.weread.qq.com/wrepub/epub_31594821_291)

> 给一个定位元素加上z-index是创建层叠上下文最主要的方式，但还有别的属性也能创建，比如小于1的opacity属性，还有transform、filter属性。由于这些属性主要会影响元素及其子元素渲染的方式，因此一起绘制父子元素。文档根节点（`<html>`）也会给整个页面创建一个顶级的层叠上下文。

所有层叠上下文内的元素会按照以下顺序，从后到前叠放：

❑ 层叠上下文的根

❑ z-index为负的定位元素（及其子元素）

❑ 非定位元素

❑ z-index为auto的定位元素（及其子元素）

❑ z-index为正的定位元素（及其子元素）


有些开发人员会忍不住给页面的大量元素使用定位。一定要克制这种冲动。定位用得越多，网页就越复杂，也就越难调试。如果你定位了大量元素，就回头评估一下现在的情况，尤其是当你发现很难调试出自己想要的布局时，一定要反思。如果可以用别的方法实现某个布局，应该优先用那些方法。

## 响应式设计
应该如何设计网站，才能让用户在任何设备上访问时，网站都既实用又美观？最初开发人员通过创建两个网站来解决这个问题：桌面版和移动版。例如，针对移动设备，服务器会将http://www.wombatcoffee.com重定向到http://m.wom-batcoffee.com。移动版网站通常对小屏幕用户提供的体验较少，设计得更精简。

要创建一个网站，就可以在智能手机、平板，或者其他任何设备上运行。网页设计师Ethan Marcotte称这种方式为响应式设计（responsive design）。

响应式设计的三大原则如下。

(1) 移动优先。这意味着在实现桌面布局之前先构建移动版的布局。

(2) @media规则。使用这个样式规则，可以为不同大小的视口定制样式。用这一语法，通常叫作媒体查询（media queries），写的样式只在特定条件下才会生效。

(3) 流式布局。这种方式允许容器根据视口宽度缩放尺寸。

### 媒体查询@media
 ❑ (min-height: 20em)——匹配高度大于等于20em的视口。

 ❑ (max-height: 20em)——匹配高度小于等于20em的视口。

 ❑ (orientation: landscape)——匹配宽度大于高度的视口。

 ❑ (orientation: portrait)——匹配高度大于宽度的视口。

 ❑ (min-resolution: 2dppx)——匹配屏幕分辨率大于等于2dppx（dppx指每个CSS像素里包含的物理像素点数）的设备，比如视网膜屏幕。

 ❑ (max-resolution: 2dppx)——匹配屏幕分辨率小于等于2dppx的设备。

最后一个媒体查询的选项是媒体类型（mediatype）。常见的两种媒体类型是screen和  print。使用print媒体查询可以控制打印时的网页布局，这样就能在打印时去掉背景图（节省墨水），隐藏不必要的导航栏。当用户打印网页时，他们通常只想打印主体内容。


### 响应式图片
在响应式设计中，图片需要特别关注。不仅要让图片适应屏幕，还要考虑移动端用户的带宽限制。图片通常是网页上最大的资源。首先要保证图片充分压缩。在图片编辑器中选择“Save for Web”选项能够极大地减小图片体积，或者用别的图片压缩工具压缩图片，比如tinypng网站。

![img](https://res.weread.qq.com/wrepub/epub_31594821_331)

媒体查询能够解决用CSS加载图片的问题，但是HTML里的`<img>`标签怎么办呢？对于这种行内图片，有另一个重要的解决方法：srcset属性（“source set”的缩写）。这个属性是HTML的一个较新的特性。它可以为一个<img>标签指定不同的图片URL，并指定相应的分辨率。

```html
<img
  srcset="elva-fairy-480w.jpg 480w, elva-fairy-800w.jpg 800w"
  sizes="(max-width: 600px) 480px,
         800px"
  src="elva-fairy-800w.jpg"
  alt="Elva dressed as a fairy" />
```
有了这些属性后，浏览器会：
1. 查看屏幕尺寸、像素密度、缩放级别、屏幕方向和网络速度。
2. 找出 sizes 列表中第一个为真的媒体条件。
3. 查看该媒体查询对应的插槽大小。
4. 加载 srcset 列表中引用的与插槽大小相同的图片，如果没有，则加载第一个大于所选插槽大小的图片。

> 图片作为流式布局的一部分，请始终确保它不会超过容器的宽度。为了避免这种情况发生，一劳永逸的办法是在样式表加入规则

```css
img { max-width: 100%; }
```