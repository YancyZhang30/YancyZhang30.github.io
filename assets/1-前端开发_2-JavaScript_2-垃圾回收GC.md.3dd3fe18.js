import{_ as s,v as a,b as n,R as l}from"./chunks/framework.caa0fbaf.js";const b=JSON.parse('{"title":"GC","description":"","frontmatter":{},"headers":[],"relativePath":"1-前端开发/2-JavaScript/2-垃圾回收GC.md","filePath":"1-前端开发/2-JavaScript/2-垃圾回收GC.md","lastUpdated":1696986769000}'),p={name:"1-前端开发/2-JavaScript/2-垃圾回收GC.md"},o=l(`<h1 id="gc" tabindex="-1">GC <a class="header-anchor" href="#gc" aria-label="Permalink to &quot;GC&quot;">​</a></h1><p>像 C 语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()。相反，JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。释放的过程称为垃圾回收。这个“自动”是混乱的根源，并让 JavaScript（和其他高级语言）开发者错误的感觉他们可以不关心内存管理。</p><h2 id="引用计数" tabindex="-1">引用计数 <a class="header-anchor" href="#引用计数" aria-label="Permalink to &quot;引用计数&quot;">​</a></h2><p>垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。例如，一个 Javascript 对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。</p><p>在这里，“对象”的概念不仅特指 JavaScript 对象，还包括函数作用域（或者全局词法作用域）。</p><p>这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> o </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">b</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">},</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量 o</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 很显然，没有一个可以被垃圾收集</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> o2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> o</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// o2 变量是第二个对“这个对象”的引用</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">o </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 现在，“这个对象”只有一个 o2 变量的引用了，“这个对象”的原始引用 o 已经没有</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> oa </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> o2</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 引用“这个对象”的 a 属性</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 现在，“这个对象”有两个引用了，一个是 o2，一个是 oa</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">o2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">yo</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 虽然最初的对象现在已经是零引用了，可以被垃圾回收了</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 但是它的属性 a 的对象还在被 oa 引用，所以还不能回收</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">oa </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// a 属性的那个对象现在也是零引用了</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 它可以被垃圾回收了</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h3 id="循环引用" tabindex="-1">循环引用 <a class="header-anchor" href="#循环引用" aria-label="Permalink to &quot;循环引用&quot;">​</a></h3><p>该算法有个限制：无法处理循环引用的事例。在下面的例子中，两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">f</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">o</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{};</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">o2</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{};</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">o</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">o2</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// o 引用 o2</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">o2</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">o</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// o2 引用 o</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">azerty</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#82AAFF;">f</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h2 id="标记清除" tabindex="-1">标记清除 <a class="header-anchor" href="#标记清除" aria-label="Permalink to &quot;标记清除&quot;">​</a></h2><p>这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。</p><p>这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。</p><p>这个算法比前一个要好，因为“有零引用的对象”总是不可获得的，但是相反却不一定，参考“循环引用”。</p><p>从 2012 年起，所有现代浏览器都使用了标记 - 清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记 - 清除算法的改进，并没有改进标记 - 清除算法本身和它对“对象是否不再需要”的简化定义。</p><p>核心思想：将垃圾回收分为标记和清除两个阶段，首先遍历所有对象找到活动对象进行标记，然后遍历所有对象清除没有标记的对象</p><h3 id="循环引用不再是问题了" tabindex="-1">循环引用不再是问题了 <a class="header-anchor" href="#循环引用不再是问题了" aria-label="Permalink to &quot;循环引用不再是问题了&quot;">​</a></h3><p>在上面的示例中，函数调用返回之后，两个对象从全局对象出发无法获取。因此，他们将会被垃圾回收器回收。第二个示例同样，一旦 div 和其事件处理无法从根获取到，他们将会被垃圾回收器回收。</p><h3 id="限制-那些无法从根对象查询到的对象都将被清除" tabindex="-1">限制：那些无法从根对象查询到的对象都将被清除 <a class="header-anchor" href="#限制-那些无法从根对象查询到的对象都将被清除" aria-label="Permalink to &quot;限制：那些无法从根对象查询到的对象都将被清除&quot;">​</a></h3><p>尽管这是一个限制，但实践中我们很少会碰到类似的情况，所以开发者不太会去关心垃圾回收机制。</p><h2 id="标记整理" tabindex="-1">标记整理 <a class="header-anchor" href="#标记整理" aria-label="Permalink to &quot;标记整理&quot;">​</a></h2><p>核心思想：标记整理可以看作是标记清除的增强版，标记阶段和上面一致，只是在清理阶段会先执行整理，移动对象位置再清除未标记的对象 优点：</p><ol><li>相对以上，能够解决空间碎片化的问题</li></ol><h2 id="v8引擎-垃圾回收策略" tabindex="-1">V8引擎（垃圾回收策略） <a class="header-anchor" href="#v8引擎-垃圾回收策略" aria-label="Permalink to &quot;V8引擎（垃圾回收策略）&quot;">​</a></h2><p>特点：即时编译、内存涉限（64位位1.5G;32位800M）</p><p>采用分代回收的思想，将内存分为<code>新生代</code>、<code>老生代区</code>，针对不同区采用<code>不同的垃圾回收算法</code>。常用的GC算法有：分代回收、空间复制、标记清除、标记整理、标记增量。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">from </span><span style="color:#FFCB6B;">to</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;">新生代</span></span>
<span class="line"><span style="color:#A6ACCD;">老生代</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>回收过程采用<code>复制算法</code> + <code>标记整理</code>算法，先将新生代内存区分为两个等大小空间，使用空间为From，空间空间为To。</p><p><img src="https://z1.ax1x.com/2023/10/10/pPzk0Pg.png" alt="垃圾回收"></p><p>V8的垃圾回收策略是将内存分为新生代和老生代。</p><ul><li>新生代中为存活时间较短的对象，老生代中为存活时间较长或常驻对象；</li><li>新生代又被划分为2个等大的内存空间，一个叫做使用空间（from），用于存放活动对象，另一个叫做空闲空间（to）；</li><li>新生代的垃圾回收算法称之为Scavenge算法。</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>默认情况下，32位系统新生代内存大小为16M，老生代内存大小为700M，64位系统下，新生代内存大小为32M，老生代内存大小为1.4G。</p></div><ol><li>从from空间中分配内存空间来存储对象，找出当前存活的对象（也可称为被引用的对象）拷贝至to空间，并将from空间中的非活动对象清除。</li><li>当to空间的使用率超过25%时，即将from空间和to空间调换，原来的from空间变成to空间，原来的to空间变成from空间。</li><li>经过一轮Scavenge算法后，from空间中上一轮存活的对象本轮如果仍然为活动对象，则将该对象移动至老生代中，如此循环操作。</li></ol><h3 id="新生代" tabindex="-1">新生代 <a class="header-anchor" href="#新生代" aria-label="Permalink to &quot;新生代&quot;">​</a></h3><p>新生代垃圾回收主要处理新创建的对象，这些对象往往很快就会变得不再使用。V8 引擎使用了<code>复制算法</code>与<code>标记整理算法</code>来实现新生代垃圾回收。</p><p>将新生代内存空间分为两个区域：From 空间和 To 空间。当 From 空间被填满时，V8 就会启动垃圾回收过程，将 From 空间中的存活对象复制到 To 空间中，然后清空 From 空间。最后，From 空间和 To 空间交换，To 空间变成新的 From 空间。这样，新生代垃圾回收就完成了。</p><h3 id="老生代" tabindex="-1">老生代 <a class="header-anchor" href="#老生代" aria-label="Permalink to &quot;老生代&quot;">​</a></h3><p>老生代垃圾回收通常比新生代垃圾回收要复杂。V8 引擎采用了两种不同的算法来实现老生代垃圾回收：<code>标记请除</code>和<code>标记整理算法</code>。</p><p>在标记整理算法中，V8 引擎首先将所有对象标记为未标记。然后，从根对象开始遍历所有对象，将能够访问到的对象标记为已标记。接着，V8 引擎将所有已标记的对象移动到内存的一端，从而在内存中创建了一个连续的区域。最后，V8 引擎清除所有未标记的对象，并将它们的内存空间加入空闲链表中，以便下次分配对象时使用。</p><p>老生代采用了标记-清除（Mark-Sweep）和标记-整理（Mark-Compact）两种算法。标记-清除算法在标记阶段遍历所有对象并标记活动对象，在清除阶段回收非活动对象的空间。标记-整理算法在标记-清除的基础上，会在清除阶段进行内存整理，移动对象位置让他们在内存中连续排列，这样可以解决内存碎片化的问题。</p><p>V8 引擎采用了许多优化措施来提高老生代垃圾回收的效率。其中一个重要的优化措施是增量标记。在增量标记中，V8 引擎会将垃圾回收过程分成多个阶段，每个阶段只标记一部分对象。这样，垃圾回收的过程可以与应用程序同时进行，避免了长时间的阻塞。</p><p><img src="https://z1.ax1x.com/2023/10/10/pPzkqZ6.png" alt="垃圾回收"></p><p>另一个优化措施是并发标记。在并发标记中，V8 引擎将标记对象的任务交给后台线程进行处理，同时应用程序可以继续执行。这样，垃圾回收过程不会阻塞应用程序的执行，从而提高了整体的性能。</p><h3 id="垃圾回收优化策略" tabindex="-1">垃圾回收优化策略 <a class="header-anchor" href="#垃圾回收优化策略" aria-label="Permalink to &quot;垃圾回收优化策略&quot;">​</a></h3><ol><li>延迟回收：由于垃圾回收会带来运行阻塞，因此可以选择在CPU空闲时或系统资源充足时执行垃圾回收，从而尽可能减少对应用程序运行的影响。</li><li>增量标记：由于全堆垃圾回收会导致JS应用暂停执行，为了减少全堆垃圾回收带来的卡顿，V8采用增量标记的策略。也就是将一次完整的垃圾回收分解为多个小的步骤，同时让垃圾回收和应用逻辑交替执行，以达到流畅的用户体验。</li><li>对象晋升：在新生代中存活下来的对象会被移动到老生代中，这就是对象晋升策略。在V8中通常采用<code>两次垃圾回收</code>后仍然存活的对象会被晋升到老生代。</li><li>空间预留：在执行垃圾回收时，会预留一部分空间，避免因空间不足导致频繁的垃圾回收。</li></ol><h3 id="内存限制和内存泄漏" tabindex="-1">内存限制和内存泄漏 <a class="header-anchor" href="#内存限制和内存泄漏" aria-label="Permalink to &quot;内存限制和内存泄漏&quot;">​</a></h3><p>V8 引擎中的内存限制是通过两个参数进行控制的：--max-old-space-size 和 --max-new-space-size。--max-old-space-size 参数控制老生代区域的最大内存大小，--max-new-space-size 参数控制新生代区域的最大内存大小。当内存占用超过这些限制时，V8 引擎就会触发垃圾回收。</p><p>内存泄漏是一种常见的问题，它可能导致应用程序占用过多的内存，从而降低系统的性能。在 V8 引擎中，内存泄漏通常是由于对全局变量、闭包等长期存在的对象的引用没有被正确地释放导致的。为了避免内存泄漏，开发人员需要注意对对象的引用计数，及时释放不再使用的对象。</p>`,48),e=[o];function r(c,t,i,y,D,F){return a(),n("div",null,e)}const d=s(p,[["render",r]]);export{b as __pageData,d as default};
