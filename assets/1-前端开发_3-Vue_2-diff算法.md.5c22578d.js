import{_ as s,v as a,b as e,R as l}from"./chunks/framework.caa0fbaf.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"1-前端开发/3-Vue/2-diff算法.md","filePath":"1-前端开发/3-Vue/2-diff算法.md","lastUpdated":1696986769000}'),n={name:"1-前端开发/3-Vue/2-diff算法.md"},d=l(`<div class="language-text line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">old：a b d</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">new：a c d b</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol><li>第一次 oldS = a oldE = d</li></ol><p>newS = a newE = b</p><p>oldS和newS匹配，则将dom中的a节点放到第一个，已经是第一个了就不管了，此时dom的位置为：a b d</p><p>oldS和newS均后移</p><ol start="2"><li>第二次 oldS = b oldE = d</li></ol><p>newS = c newE = b</p><p>oldS和newE匹配，就将原本的b节点移动到最后，因为E是最后一个节点，他们位置要一致， 这就是上面说的：当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置，此时dom的位置为：a d b</p><p>oldS后移，newE前移</p><ol start="3"><li>第三次 oldS = d odlE = d</li></ol><p>newS = c newE = d</p><p>oldE和E匹配，位置不变此时dom的位置为：a d b</p><ol start="4"><li>第四次 oldS++ oldE-- oldS &gt; oldE</li></ol><p>遍历结束，说明oldCh先遍历完。就将剩余的节点根据自己的的index插入到真实dom中去，此时dom位置为：a c d b</p>`,14),o=[d];function p(t,i,r,c,m,b){return a(),e("div",null,o)}const f=s(n,[["render",p]]);export{u as __pageData,f as default};
