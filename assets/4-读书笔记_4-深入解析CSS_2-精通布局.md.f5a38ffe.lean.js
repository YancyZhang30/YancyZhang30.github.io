import{_ as e,v as a,b as p,R as s}from"./chunks/framework.caa0fbaf.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"4-读书笔记/4-深入解析CSS/2-精通布局.md","filePath":"4-读书笔记/4-深入解析CSS/2-精通布局.md","lastUpdated":1719037263000}'),o={name:"4-读书笔记/4-深入解析CSS/2-精通布局.md"},l=s(`<h2 id="浮动" tabindex="-1">浮动 <a class="header-anchor" href="#浮动" aria-label="Permalink to &quot;浮动&quot;">​</a></h2><p>虽然最初创造浮动并不是为了用于页面布局，但它在布局方面表现得很出色。然而为了理解浮动，我们首先必须牢记它的设计初衷。</p><p>浮动能将一个元素（通常是一张图片）拉到其容器的一侧，这样文档流就能够包围它。这种布局在报纸和杂志中很常见，因此CSS增加了浮动来实现这种效果。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_145" alt="浮动布局"></p><p>一个元素被拉到了左侧，它也可以浮动到右侧。浮动元素会被移出正常文档流，并被拉到容器边缘。 文档流会重新排列，但是它会包围浮动元素此刻所占据的空间。如果让多个元素向<code>同侧浮动</code>，它们就会挨着排列。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_146" alt="浮动布局2"></p><h3 id="容器折叠-高度塌陷" tabindex="-1">容器折叠/高度塌陷 <a class="header-anchor" href="#容器折叠-高度塌陷" aria-label="Permalink to &quot;容器折叠/高度塌陷&quot;">​</a></h3><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_153" alt="高度塌陷"></p><p>白色的背景区域是怎么回事？白色背景的确出现在了页面标题（“Running tips”）后面，但是并没有向下延伸，直到包含媒体盒子。</p><p>这是因为浮动元素不同于普通文档流的元素，它们的高度不会加到父元素上。这可能看起来很奇怪，但是恰好体现了浮动的设计初衷。</p><p>解决办法：</p><ol><li><p>用clear属性清除浮动 clear: both声明让该元素移动到浮动元素的下面，而不是侧面。clear的值还可以设置为left或者right，这样只会相应地清除向左或者向右浮动的元素。因为空div本身没有浮动，所以容器就会扩展，直到包含它，因此也会包含该div上面的浮动元素。</p></li><li><p>伪元素 <img src="https://res.weread.qq.com/wrepub/epub_31594821_159" alt="伪元素"></p></li></ol><h2 id="bfc" tabindex="-1">BFC <a class="header-anchor" href="#bfc" aria-label="Permalink to &quot;BFC&quot;">​</a></h2><p>块级格式化上下文（block formatting context, BFC）。BFC是网页的一块区域，元素基于这块区域布局。虽然BFC本身是环绕文档流的一部分，但它将内部的内容与外部的上下文隔离开。这种隔离为创建BFC的元素做出了以下3件事情。</p><p>(1) 包含了内部所有元素的上下外边距。它们不 会跟BFC外面的元素产生<code>外边距折叠</code>。</p><p>(2) <code>包含了内部所有</code>的浮动元素。</p><p>(3) 不会跟BFC外面的浮动元素<code>重叠</code>。</p><p>简而言之，BFC里的内容不会跟外部的元素重叠或者相互影响。如果给元素增加clear属性，它只会清除自身所在BFC内的浮动。如果强制给一个元素生成一个新的BFC，它不会跟其他BFC重叠。</p><p>给元素添加以下的任意属性值都会创建BFC。</p><p>❑ float: left或right，不为none即可。</p><p>❑ overflow:hidden、auto或scroll，<code>不为visible</code>即可。</p><p>❑ display:inline-block、table-cell、table-caption、flex、inline-flex、grid或inline-grid。拥有这些属性的元素称为块级容器（block container）。</p><p>❑ position:absolute或position: fixed。</p><blockquote><p>说明：网页的根元素html也创建了一个顶级的BFC。</p></blockquote><h2 id="网格系统" tabindex="-1">网格系统 <a class="header-anchor" href="#网格系统" aria-label="Permalink to &quot;网格系统&quot;">​</a></h2><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_173" alt="网格"></p><p>选取12作为列数是因为它能够被2、3、4、6整除，组合起来足够灵活。比如可以很容易地实现一个3列布局（3个4列宽的元素）或者一个4列布局（4个3列宽的元素）。还可以实现非对称的布局，比如一个9列宽的主元素和一个3列宽的侧边栏。在每个子元素里可以放置任意标记。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_177" alt="构建"></p><p>常见组件库的栅格组件，应该也是这个思想。</p><h2 id="flexbox" tabindex="-1">FlexBox <a class="header-anchor" href="#flexbox" aria-label="Permalink to &quot;FlexBox&quot;">​</a></h2><p>Flexbox，全称弹性盒子布局（Flexible Box Layout），是一种新的布局方式。跟浮动布局相比，Flexbox的可预测性更好，还能提供更精细的控制。它也能轻松解决困扰我们许久的垂直居中和等高列问题。</p><p>一切要从我们熟悉的display属性开始。给元素添加display: flex，该元素变成了一个弹性容器（flex container），它的直接子元素变成了弹性子元素（flex item）。</p><p>弹性子元素默认是在同一行按照从左到右的顺序并排排列。弹性容器像块元素一样<code>填满可用宽度</code>，但是弹性子元素不一定填满其弹性容器的宽度。弹性子元素高度相等，该高度由它们的<code>内容决定</code>。</p><blockquote><p>还可以用display: inline-flex。它创建了一个弹性容器，行为类似于inline-block元素。它会跟其他行内元素一起流式排列，但<code>不会自动增长到100%的宽度</code>。内部的弹性子元素跟使用display:flex创建的Flexbox里的弹性子元素行为一致。</p></blockquote><p>之前提到的display值，比如inline、inline-block等，只会影响到应用了该样式的元素，而Flexbox则不一样。一个弹性容器能控制内部元素的布局。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_190" alt="flexbox"></p><p>子元素按照主轴线排列，主轴的方向为主起点（左）到主终点（右）。垂直于主轴的是副轴。方向从副起点（上）到副终点（下）。</p><h3 id="子元素flex属性" tabindex="-1">子元素flex属性 <a class="header-anchor" href="#子元素flex属性" aria-label="Permalink to &quot;子元素flex属性&quot;">​</a></h3><p>flex属性控制弹性子元素在主轴方向上的大小（在这里指的元素的宽度）。</p><p>flex属性是三个不同大小属性的简写：<code>flex-grow</code>、<code>flex-shrink</code>和<code>flex-basis</code>。ru如果只提供了flex-grow的值（第一个参数），剩下的两个属性是<code>默认值</code>（分别是1和0%），因此flex: 2等价于flex: 210%。</p><p>通常首选简写属性，但也可以分别声明三个属性。</p><p>flex-basis定义了元素大小的基准值，即一个初始的“主尺寸”。flex-basis属性可以设置为任意的width值，包括px、em、百分比。它的<code>初始值是auto</code>，此时浏览器会检查元素是否设置了width属性值。如果有，则使用width的值作为flex-basis的值；如果没有，<code>则用元素内容自身的大小</code>。</p><p>每个弹性子元素的<code>flex-basis值计算出来后</code>，它们（加上子元素之间的外边距）加起来会占据一定的宽度。加起来的宽度不一定正好填满弹性容器的宽度，可能会有留白。</p><p>多出来的留白（或剩余宽度）会按照flex-grow（增长因子）的值分配给每个弹性子元素，flex-grow的值为非负整数。如果一个弹性子元素的<code>flex-grow值为0</code>，那么它的宽度<code>不会超过flex-basis的值</code>；如果某个弹性子元素的<code>增长因子非0</code>，那么这些元素会增长到所有的剩余空间被分配完，也就意味着弹性子元素会填满容器的宽度。</p><p>flex-grow的值越大，元素的“权重”越高，也就会占据更大的剩余宽度。一个flex-grow:2的子元素增长的宽度为flex-grow: 1的子元素的两倍。</p><p>还记得前面的三个板块吗？简写声明flex: 2和flex: 1设置了一个弹性基准值为0%，因此容器宽度的100%都是剩余宽度（减去两列之间1.5em的外边距）。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_207" alt="flex"></p><p>flex-shrink属性与flex-grow遵循相似的原则，根据flex-basis计算出弹性子元素的初始主尺寸后，它们的累加值可能会<code>超出弹性容器的可用宽度</code>。如果不用flex-shrink，就会导致溢出。</p><p>每个子元素的flex-shrink值代表了它是否应该收缩以防止溢出。如果某个子元素为flex-shrink: 0，则不会收缩；如果值大于0，则会收缩至不再溢出。按照flex-shrink值的比例，值越大的元素收缩得越多。</p><ul><li><p><code>&lt;&#39;flex-grow&#39;&gt;</code> 定义 flex 项目的 flex-grow 。负值无效。省略时默认值为 1。 (初始值为 0)</p></li><li><p><code>&lt;&#39;flex-shrink&#39;&gt;</code> 定义 flex 元素的 flex-shrink 。负值无效。省略时默认值为1。 (初始值为 1)</p></li><li><p><code>&lt;&#39;flex-basis&#39;&gt;</code> 定义 flex 元素的 flex-basis 属性。若值为0，则必须加上单位，以免被视作伸缩性。省略时默认值为 0。(初始值为 auto)</p></li></ul><blockquote><p>即如果没有设置flex属性，那么默认值就是<code>flex: 0 1 auto</code>。如果设置了flex属性（可能有1、2、3个参数），那么默认值就是<code>flex: 1 1 auto</code>。</p></blockquote><h3 id="flex-direction" tabindex="-1">flex-direction <a class="header-anchor" href="#flex-direction" aria-label="Permalink to &quot;flex-direction&quot;">​</a></h3><p>Flexbox的另一个重要功能是能够切换主副轴方向，用弹性容器的flex-direction属性控制。如前面的例子所示，它的初始值（row）控制子元素按从左到右的方向排列；指定flex-direction: column能控制弹性子元素沿垂直方向排列（从上到下）。Flexbox还支持row-reverse让元素从右到左排列，column-reverse让元素从下到上排列。</p><h3 id="容器属性" tabindex="-1">容器属性 <a class="header-anchor" href="#容器属性" aria-label="Permalink to &quot;容器属性&quot;">​</a></h3><p>flex-wrap属性允许弹性子元素换到新的一行或多行显示。它可以设置为nowrap（初始值）、wrap或者wrap-reverse。启用换行后，子元素不再根据flex-shrink值收缩，任何超过弹性容器的子元素都会换行显示。</p><p>flex-flow属性是flex-direction和flex-wrap的简写。例如，flex-flow:column wrap指定弹性子元素按照从上到下的方式排列，必要时换到新的一列。</p><p>当子元素未填满容器时，justify-content属性控制子元素沿主轴方向的间距。它的值包括几个关键字：flex-start、flex-end、center、space-between以及space-around。默认值flex-start让子元素从主轴的开始位置顺序排列，比如主轴方向为从左到右的话，开始位置就是左边。如果不设置外边距，那么子元素之间不会产生间距。如果值为flex-end，子元素就从主轴的结束位置开始排列，center的话则让子元素居中。</p><p>justify-content控制子元素在主轴方向的对齐方式，align-items则控制子元素在副轴方向的对齐方式。align-items的初始值为stretch，在水平排列的情况下让所有子元素填充容器的高度，在垂直排列的情况下让子元素填充容器的宽度，因此它能实现等高列。</p><p>如果开启了换行（用flex-wrap）, align-content属性就可以控制弹性容器内沿副轴方向每行之间的间距。它支持的值有flex-start、flex-end、center、stretch（初始值）、space-between以及space-around。这些值对间距的处理类似上面的justify-content。</p><h3 id="子元素属性" tabindex="-1">子元素属性 <a class="header-anchor" href="#子元素属性" aria-label="Permalink to &quot;子元素属性&quot;">​</a></h3><p>align-items属性控制弹性子元素沿着容器副轴方向的对齐方式。它跟弹性容器的align-items属性效果相同，但是它能单独给弹性子元素设定不同的对齐方式。auto为初始值，会以容器的align-items值为准。其他值会覆盖容器的设置。align-self属性支持的关键字与align-items一样：flex-start、flex-end、center、stretch以及baseline。</p><p>正常情况下，弹性子元素按照在HTML源码中出现的顺序排列。它们沿着主轴方向，从主轴的起点开始排列。使用order属性能改变子元素排列的顺序。还可以将其指定为任意正负整数。如果多个弹性子元素有一样的值，它们就会按照源码顺序出现。</p><p>初始状态下，所有的弹性子元素的order都为0。指定一个元素的值为−1，它会移动到列表的最前面；指定为1，则会移动到最后。可以按照需要给每个子元素指定order以便重新编排它们。这些值不一定要连续。</p><h2 id="网格布局grid" tabindex="-1">网格布局Grid <a class="header-anchor" href="#网格布局grid" aria-label="Permalink to &quot;网格布局Grid&quot;">​</a></h2><p>CSS网格可以定义由行和列组成的二维布局，然后将元素放置到网格中。有些元素可能只占据网格的一个单元，另一些元素则可能占据多行或多列。网格的大小既可以精确定义，也可以根据自身内容自动计算。你既可以将元素精确地放置到网格某个位置，也可以让其在网格内自动定位，填充划分好的区域。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_224" alt="grid"></p><p>跟Flexbox类似，网格布局也是作用于两级的DOM结构。设置为display: grid的元素成为一个网格容器（grid container）。它的子元素则变成网格元素（grid items）。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_227" alt="grid"></p><p>接下来是新属性：grid-template-columns和grid-template-rows。</p><p>这两个属性定义了网格每行每列的大小。本例使用了一种<code>新单位fr</code>，代表每一列（或每一行）的分数单位<code>（fraction unit）</code>。这个单位跟Flexbox中<code>flex-grow因子</code>的表现一样。grid-template-columns:1fr 1fr 1fr表示<code>三列等宽</code>。</p><p>不一定非得用分数单位，可以使用其他的单位，比如px、em或百分数。也可以混搭这几种单位，例如，grid-template-columns:300px 1fr定义了一个固定宽度为300px的列，后面跟着一个会填满剩余可用空间的列。2fr的列宽是1fr的两倍。</p><p>最后，grid-gap属性定义了每个网格单元之间的间距。也可以用两个值分别指定垂直和水平方向的间距（比如grid-gap: 0.5em 1em）。</p><h3 id="网格刨析" tabindex="-1">网格刨析 <a class="header-anchor" href="#网格刨析" aria-label="Permalink to &quot;网格刨析&quot;">​</a></h3><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_228" alt="grid"></p><p>❑ 网格线（grid line）—— 网格线构成了网格的框架。一条网格线可以水平或垂直，也可以位于一行或一列的任意一侧。如果指定了grid-gap的话，它就位于网格线上。</p><p>❑ 网格轨道（grid track）—— 一个网格轨道是两条相邻网格线之间的空间。网格有水平轨道（行）和垂直轨道（列）。</p><p>❑ 网格单元（grid cell）—— 网格上的单个空间，水平和垂直的网格轨道交叉重叠的部分。</p><p>❑ 网格区域（grid area）—— 网格上的矩形区域，由一个到多个网格单元组成。该区域位于两条垂直网格线和两条水平网格线之间。</p><p>构建网格布局时会涉及这些组成部分。比如声明grid-template-columns: 1fr 1fr 1fr就会定义三个等宽且垂直的网格轨道，同时还定义了四条垂直的网格线：一条在网格最左边，两条在每个网格轨道之间，还有一条在最右边。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_232" alt="grid"></p><p>代码首先设置了网格容器，并用<code>grid-template-columns</code>和<code>grid-template-rows</code>定义了网格轨道。因为列的分数单位分别是2fr和1fr，所以第一列的宽度是第二列的两倍。</p><p>定义行的时候用到了一个新方法：repeat()函数。它在声明多个网格轨道的时候提供了简写方式。grid-template-rows: repeat(4, auto)；定义了四个<code>水平网格轨道</code>，高度为auto，这等价于grid-template-rows: auto auto auto auto。轨道大小设置为auto，轨道会根据<code>自身内容扩展</code>。</p><h3 id="网格编号" tabindex="-1">网格编号 <a class="header-anchor" href="#网格编号" aria-label="Permalink to &quot;网格编号&quot;">​</a></h3><p>网格轨道定义好之后，要将每个网格元素放到特定的位置上。浏览器给网格里的每个网格线都赋予了编号，如图所示。CSS用这些编号指出每个元素应该摆放的位置。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_234" alt="网格编号"></p><p>可以在grid-column和grid-row属性中用网格线的编号指定<code>网格元素</code>的位置。如果想要一个网格元素在<code>垂直方向上跨越1号网格线到3号网格线</code>，就需要给元素设置grid-column: 1 / 3。或者设置grid-row: 3 / 5让元素在<code>水平方向上跨越3号网格线到5号网格线</code>。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_235" alt="网格编号"></p><p>这段代码将main元素放在第一列（1号到2号网格线之间），跨越第三行到第四行（3号到5号网格线）的位置。侧边栏的两个板块放在右列（2号到3号网格线之间），并且在第三行和第四行上下排列。</p><blockquote><p>这些属性实际上是简写属性：grid-column是grid-column-start和grid-column-end的简写；grid-row是grid-row-start和grid-row-end的简写。中间的斜线只在简写属性里用于区分两个值，斜线前后的空格不作要求。</p></blockquote><h3 id="与flexbox配合" tabindex="-1">与FlexBox配合 <a class="header-anchor" href="#与flexbox配合" aria-label="Permalink to &quot;与FlexBox配合&quot;">​</a></h3><p>❑ Flexbox本质上是一维的，而网格是二维的。</p><p>❑ Flexbox是以内容为切入点由内向外工作的，而网格是以布局为切入点从外向内工作的。</p><p>因为Flexbox是一维的，所以它很适合用在相似的元素组成的行（或列）上。它支持用flex-wrap换行，但是没法让上一行元素跟下一行元素对齐。相反，网格是二维的，旨在解决一个轨道的元素跟另一个轨道的元素对齐的问题。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_237" alt="FlexBox"></p><h3 id="替代语法" tabindex="-1">替代语法 <a class="header-anchor" href="#替代语法" aria-label="Permalink to &quot;替代语法&quot;">​</a></h3><p>布局网格元素还有另外两个替代语法：命名的网格线和命名的网格区域。</p><p>有时候记录所有网格线的编号实在太麻烦了，尤其是在处理很多网格轨道时。为了能简单点，可以给<code>网格线命名</code>，并在布局时使用<code>网格线的名称</code>而不是编号。声明网格轨道时，可以在中括号内写上网格线的名称，如下代码片段所示。</p><h4 id="命名网格线" tabindex="-1">命名网格线 <a class="header-anchor" href="#命名网格线" aria-label="Permalink to &quot;命名网格线&quot;">​</a></h4><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_242" alt="命名的网格线"></p><p>这条声明定义了两列的网格，三条垂直的网格线分别叫作start、center和end。之后定义网格元素在网格中的位置时，可以不用编号而是用这些名称来声明。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_243" alt="命名的网格线"></p><p>还可以给同一个网格线提供多个名称，比如下面的声明（为了可读性，这里将代码换行了）。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_244" alt="命名的网格线"></p><p>在这条声明里，2号网格线既叫作left-end也叫作right-start，之后可以任选一个名称使用。这里还有一个彩蛋：将网格线命名为left-start和left-end，就定义了一个叫作<code>left的区域</code>，这个区域覆盖两个网格线之间的区域。-start和-end后缀作为<code>关键字</code>，定义了两者之间的区域。如果给元素设置<code>grid-column: left</code>，它就会跨越从<code>left-start到left-end</code>的区域。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_245" alt="命名的网格线"></p><h4 id="命名网格区域" tabindex="-1">命名网格区域 <a class="header-anchor" href="#命名网格区域" aria-label="Permalink to &quot;命名网格区域&quot;">​</a></h4><p>另一个方式是<code>命名网格区域</code>。不用计算或者命名网格线，直接用命名的网格区域将元素定位到网格中。实现这一方法需要借助网格容器的grid-template-areas性和网格元素的grid-area属性。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_247" alt="命名的网格区域"></p><p>grid-template-areas属性使用了一种ASCIIart的语法，可以直接在CSS中画一个可视化的网格形象。该声明给出了一系列加引号字符串，每一个字符串代表网格的一行，字符串内用空格区分每一列。</p><blockquote><p>警告: 每个命名的网格区域必须组成一个矩形。不能创造更复杂的形状，比如L或者U型。</p></blockquote><p>还可以用句点（.）作为名称，这样便能空出一个网格单元。比如，以下代码定义了四个网格区域，中间围绕着一个空的网格单元。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_248" alt="命名的网格区域"></p><p>网格布局共设计了三种语法：编号的网格线、命名的网格线、命名的网格区域。最后一个可能更受广大开发人员喜爱，尤其是明确知道每个网格元素的位置时，这种方式用起来更舒服。</p><h3 id="显式和隐式网格" tabindex="-1">显式和隐式网格 <a class="header-anchor" href="#显式和隐式网格" aria-label="Permalink to &quot;显式和隐式网格&quot;">​</a></h3><p>在某些场景下，你可能不清楚该把元素放在网格的哪个位置上。当处理大量的网格元素时，挨个指定元素的位置未免太不方便。当元素是从数据库获取时，元素的个数可能是未知的。在这些情况下，以一种宽松的方式定义网格可能更合理，剩下的交给布局算法来放置网格元素。</p><p>这时需要用到隐式网格（implicit grid）。使用grid-template-＊属性定义网格轨道时，创建的是显式网格（explicit grid），但是有些网格元素仍然可以放在显式轨道外面，此时会<code>自动创建隐式轨道以扩展网格</code>，从而包含这些元素。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_249" alt="隐式网格"></p><p>隐式网格轨道默认大小为auto，也就是它们会扩展到能容纳网格元素内容。可以给网格容器设置grid-auto-columns和grid-auto-rows，为隐式网格轨道指定一个大小（比如，grid-auto-columns: 1fr）。</p><blockquote><p>在指定网格线的时候，隐式网格轨道不会改变负数的含义。负的网格线编号仍然是从显式网格的右下开始的。</p></blockquote><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_253" alt="隐式网格"></p><p>网格布局模块规范提供了另一个属性grid-auto-flow，它可以控制布局算法的行为。它的初始值是row，上一段描述的就是这个值的行为。如果值为column，它就会将元素优先放在网格列中，只有当一列填满了，才会移动到下一行。</p><p>还可以额外加一个关键字dense（比如，grid-auto-flow: column dense）。它让算法紧凑地填满网格里的空白，尽管这会改变某些网格元素的顺序。加上这个关键字，小元素就会“回填”大元素造成的空白区域</p><h3 id="特性查询" tabindex="-1">特性查询 <a class="header-anchor" href="#特性查询" aria-label="Permalink to &quot;特性查询&quot;">​</a></h3><p>CSS最近添加了一个叫作特性查询（featurequery）的功能，该功能有助于解决这个问题，如下代码片段所示。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_262" alt="隐式网格"></p><p>@supports规则后面跟着一个小括号包围的声明。如果浏览器理解这个声明（在本例中，浏览器支持网格），它就会使用大括号里面的所有样式规则。如果它不理解小括号里的声明，就不会使用这些样式规则。</p><h3 id="对齐" tabindex="-1">对齐 <a class="header-anchor" href="#对齐" aria-label="Permalink to &quot;对齐&quot;">​</a></h3><p>CSS给网格布局提供了三个调整属性：justify-content、justify-items、justify-self。这些属性控制了网格元素在水平方向上的位置。我是这样记的：就像在文字处理器里调整文字位置，让它们在水平方向上分布。</p><p>还有三个对齐属性：align-content、align-items、align-self。这些属性控制网格元素在垂直方向上的位置。我是这样记的：就像表格布局里的vertical-align属性。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_266" alt="对齐"></p><p>可以用justify-content和align-content设置网格容器内的网格轨道在水平方向和垂直方向上的位置，特别是当网格元素的大小无法填满网格容器时。参考以下代码。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_267" alt="对齐"></p><p>（Flexbox里则是flex-end）。</p><p>❑ center——将网格轨道放在网格容器的中间。</p><p>❑ stretch——将网格轨道拉伸至填满网格容器。</p><p>❑ space-between——将剩余空间平均分配到每个网格轨道之间（它能覆盖任何grid-gap值）。</p><p>❑ space-around——将空间分配到每个网格轨道之间，且在两端各加上一半的间距。</p><p>❑ space-evenly——将空间分配到每个网格轨道之间，且在两端各加上同等大小的间距（Flexbox规范不支持）。</p><h2 id="定位和层叠上下文" tabindex="-1">定位和层叠上下文 <a class="header-anchor" href="#定位和层叠上下文" aria-label="Permalink to &quot;定位和层叠上下文&quot;">​</a></h2><h3 id="定位position" tabindex="-1">定位position <a class="header-anchor" href="#定位position" aria-label="Permalink to &quot;定位position&quot;">​</a></h3><p>position属性。它可以用来构建下拉菜单、模态框以及现代Web应用程序的一些基本效果。定位可能变得很复杂。许多开发人员对它只有粗略的理解。如果不完全了解定位以及它可能带来的后果，就很容易给自己挖坑。有时候你可能会把错误的元素放在其他元素前面，要解决这个问题却没有那么简单。</p><p>position属性的初始值是<strong>static</strong>。</p><p>如果把它改成其他值，我们就说元素就<strong>被定位了</strong>。而如果元素使用了静态定位，那么就说它未被定位。</p><h4 id="固定定位fixed" tabindex="-1">固定定位fixed <a class="header-anchor" href="#固定定位fixed" aria-label="Permalink to &quot;固定定位fixed&quot;">​</a></h4><p>固定定位不如其他定位类型用得普遍，但它是最好理解的一种定位类型，因此我先从它开始介绍。给一个元素设置position: fixed就能将元素放在视口的任意位置。这需要搭配四种属性一起使用：top、right、bottom和left。这些属性的值决定了固定定位的元素与浏览器视口边缘的距离。比如，top: 3em表示元素的上边缘距离视口顶部3em。</p><p>设置这四个值还隐式地定义了<code>元素的宽高</code>。比如指定left: 2em; right: 2em表示元素的左边缘距离视口左边2em，右边缘距离视口右边2em。因此元素的宽度等于视口总宽度减去4em。top、bottom和视口高度也是这样的关系。</p><p>定位一个元素时，不要求指定四个方向的值，可以只指定需要的方向值，然后用width和/或height来决定它的大小，也可以让元素本身来决定大小。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_271" alt="定位"></p><h4 id="绝对定位absolute" tabindex="-1">绝对定位absolute <a class="header-anchor" href="#绝对定位absolute" aria-label="Permalink to &quot;绝对定位absolute&quot;">​</a></h4><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_273" alt="绝对定位"></p><blockquote><p>如果祖先元素都没有定位，那么绝对定位的元素会基于初始包含块（initialcontaining block）来定位。初始包含块跟视口一样大，固定在网页的顶部。</p></blockquote><h4 id="相对定位relative" tabindex="-1">相对定位relative <a class="header-anchor" href="#相对定位relative" aria-label="Permalink to &quot;相对定位relative&quot;">​</a></h4><p>相对定位可能是最不被理解的定位类型。当第一次给元素加上position: relative的时候，你通常看不到页面上有任何视觉改变。相对定位的元素以及它周围的所有元素，都还保持着原来的位置（尽管你可能会看到某些元素跑到另一些元素前面，我后面会解释这个问题）。</p><p>如果加上top、right、bottom和left属性，元素就会从原来的位置移走，但是不会改变它周围任何元素的位置。如图7-4所示，四个inline-block元素，给第二个元素加上三个额外的属性：position: relative、top: 1em、left: 2em，将其从初始位置移走，但是其他元素没有受到影响。它们还是围绕着被移走元素的初始位置，跟随着正常的文档流。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_276" alt="相对定位"></p><blockquote><p>跟固定或者绝对定位不一样，不能用top、right、bottom和left改变相对定位元素的大小。这些值只能让元素在上、下、左、右方向移动。可以用top或者bottom，但它们不能一起用（bottom会被忽略）。同理，可以用left或right，但它们也不能一起用（right会被忽略）。</p></blockquote><h4 id="粘性定位sticky" tabindex="-1">粘性定位sticky <a class="header-anchor" href="#粘性定位sticky" aria-label="Permalink to &quot;粘性定位sticky&quot;">​</a></h4><p>粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。</p><div class="language-css line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">#</span><span style="color:#F78C6C;">one</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">position</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> sticky</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">top</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10px</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。</p><p>须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p><p>注意，一个 sticky 元素会“固定”在离它最近的一个拥有<code>“滚动机制”</code>的祖先上（当该祖先的 overflow 是 hidden、scroll、auto 或 overlay 时），即便这个祖先不是最近的真实可滚动祖先。</p><h3 id="层叠上下文和z-index" tabindex="-1">层叠上下文和z-index <a class="header-anchor" href="#层叠上下文和z-index" aria-label="Permalink to &quot;层叠上下文和z-index&quot;">​</a></h3><p>浏览器将HTML解析为DOM的同时还创建了另一个树形结构，叫作渲染树（render tree）。它代表了每个元素的视觉样式和位置。同时还决定浏览器绘制元素的顺序。</p><p>顺序很重要，因为如果元素刚好重叠，后绘制的元素就会出现在先绘制的元素前面。</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">one</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">two</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">three</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_287" alt="层叠上下文"></p><p>定位元素时，这种行为会改变。浏览器会先绘制所有<code>非定位的元素</code>，然后绘制定位元素。默认情况下，所有的定位元素会出现在非定位元素<code>前面</code>。</p><p>给前两个元素加了position: relative，它们就绘制到了前面，覆盖了静态定位的第三个元素，尽管元素在HTML里的顺序并未改变。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_288" alt="层叠上下文"></p><h4 id="使用z-index控制层叠顺序" tabindex="-1">使用z-index控制层叠顺序 <a class="header-anchor" href="#使用z-index控制层叠顺序" aria-label="Permalink to &quot;使用z-index控制层叠顺序&quot;">​</a></h4><p>z-index属性的值可以是任意整数（正负都行）。z表示的是笛卡儿x-y-z坐标系里的<code>深度方向</code>。拥有较高z-index的元素出现在拥有较低z-index的元素前面。拥有负数z-index的元素出现在静态元素后面。</p><p>z-index的行为很好理解，但是使用它时要注意两个小陷阱。</p><ul><li><p>第一，z-index<code>只在定位元素上生效</code>，<code>不能</code>用它控制静态元素。</p></li><li><p>第二，给一个定位元素加上z-index可以<code>创建层叠上下文</code>。</p></li></ul><h4 id="理解层叠上下文" tabindex="-1">理解层叠上下文 <a class="header-anchor" href="#理解层叠上下文" aria-label="Permalink to &quot;理解层叠上下文&quot;">​</a></h4><p>一个层叠上下文包含一个元素或者由浏览器一起绘制的一组元素。其中一个元素会作为层叠上下文的根，比如给一个定位元素加上z-index的时候，它就变成了一个<code>新的层叠上下文的根</code>。所有后代元素就是这个层叠上下文的<code>一部分</code>。</p><p>不要将层叠上下文跟第4章的BFC弄混了，它们是两个独立的概念，尽管不一定互斥。层叠上下文负责决定哪些元素出现在另一些元素前面，而BFC负责处理文档流，以及元素是否会重叠。</p><p>实际上将层叠上下文里的所有元素一起绘制会造成严重的后果：层叠上下文之外的元素无法叠放在层叠上下文内的两个元素之间。换句话说，如果一个元素叠放在一个层叠上下文前面，那么层叠上下文里没有元素可以被拉到该元素前面。同理，如果一个元素被放在层叠上下文后面，层叠上下文里没有元素能出现在该元素后面。</p><p>这段代码包含了三个盒子，其中两个被定位，并且z-index为1，第一个盒子里面有一个绝对定位的元素，它的z-index为100。虽然第一个盒子的z-index很高，但还是出现在第二个盒子后面，因为它的父元素，即第一个盒子形成的层叠上下文在第二个盒子后面。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_290" alt="z-index"></p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_291" alt="z-index"></p><blockquote><p>给一个定位元素加上z-index是创建层叠上下文最主要的方式，但还有别的属性也能创建，比如小于1的opacity属性，还有transform、filter属性。由于这些属性主要会影响元素及其子元素渲染的方式，因此一起绘制父子元素。文档根节点（<code>&lt;html&gt;</code>）也会给整个页面创建一个顶级的层叠上下文。</p></blockquote><p>所有层叠上下文内的元素会按照以下顺序，从后到前叠放：</p><p>❑ 层叠上下文的根</p><p>❑ z-index为负的定位元素（及其子元素）</p><p>❑ 非定位元素</p><p>❑ z-index为auto的定位元素（及其子元素）</p><p>❑ z-index为正的定位元素（及其子元素）</p><p>有些开发人员会忍不住给页面的大量元素使用定位。一定要克制这种冲动。定位用得越多，网页就越复杂，也就越难调试。如果你定位了大量元素，就回头评估一下现在的情况，尤其是当你发现很难调试出自己想要的布局时，一定要反思。如果可以用别的方法实现某个布局，应该优先用那些方法。</p><h2 id="响应式设计" tabindex="-1">响应式设计 <a class="header-anchor" href="#响应式设计" aria-label="Permalink to &quot;响应式设计&quot;">​</a></h2><p>应该如何设计网站，才能让用户在任何设备上访问时，网站都既实用又美观？最初开发人员通过创建两个网站来解决这个问题：桌面版和移动版。例如，针对移动设备，服务器会将<a href="http://www.wombatcoffee.xn--comhttp-8t0lt3lewxyu4l" target="_blank" rel="noreferrer">http://www.wombatcoffee.com重定向到http</a>😕/m.wom-batcoffee.com。移动版网站通常对小屏幕用户提供的体验较少，设计得更精简。</p><p>要创建一个网站，就可以在智能手机、平板，或者其他任何设备上运行。网页设计师Ethan Marcotte称这种方式为响应式设计（responsive design）。</p><p>响应式设计的三大原则如下。</p><p>(1) 移动优先。这意味着在实现桌面布局之前先构建移动版的布局。</p><p>(2) @media规则。使用这个样式规则，可以为不同大小的视口定制样式。用这一语法，通常叫作媒体查询（media queries），写的样式只在特定条件下才会生效。</p><p>(3) 流式布局。这种方式允许容器根据视口宽度缩放尺寸。</p><h3 id="媒体查询-media" tabindex="-1">媒体查询@media <a class="header-anchor" href="#媒体查询-media" aria-label="Permalink to &quot;媒体查询@media&quot;">​</a></h3><p>❑ (min-height: 20em)——匹配高度大于等于20em的视口。</p><p>❑ (max-height: 20em)——匹配高度小于等于20em的视口。</p><p>❑ (orientation: landscape)——匹配宽度大于高度的视口。</p><p>❑ (orientation: portrait)——匹配高度大于宽度的视口。</p><p>❑ (min-resolution: 2dppx)——匹配屏幕分辨率大于等于2dppx（dppx指每个CSS像素里包含的物理像素点数）的设备，比如视网膜屏幕。</p><p>❑ (max-resolution: 2dppx)——匹配屏幕分辨率小于等于2dppx的设备。</p><p>最后一个媒体查询的选项是媒体类型（mediatype）。常见的两种媒体类型是screen和 print。使用print媒体查询可以控制打印时的网页布局，这样就能在打印时去掉背景图（节省墨水），隐藏不必要的导航栏。当用户打印网页时，他们通常只想打印主体内容。</p><h3 id="响应式图片" tabindex="-1">响应式图片 <a class="header-anchor" href="#响应式图片" aria-label="Permalink to &quot;响应式图片&quot;">​</a></h3><p>在响应式设计中，图片需要特别关注。不仅要让图片适应屏幕，还要考虑移动端用户的带宽限制。图片通常是网页上最大的资源。首先要保证图片充分压缩。在图片编辑器中选择“Save for Web”选项能够极大地减小图片体积，或者用别的图片压缩工具压缩图片，比如tinypng网站。</p><p><img src="https://res.weread.qq.com/wrepub/epub_31594821_331" alt="img"></p><p>媒体查询能够解决用CSS加载图片的问题，但是HTML里的<code>&lt;img&gt;</code>标签怎么办呢？对于这种行内图片，有另一个重要的解决方法：srcset属性（“source set”的缩写）。这个属性是HTML的一个较新的特性。它可以为一个<img>标签指定不同的图片URL，并指定相应的分辨率。</p><div class="language-html line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">img</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#C792EA;">srcset</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">elva-fairy-480w.jpg 480w, elva-fairy-800w.jpg 800w</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#C792EA;">sizes</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">(max-width: 600px) 480px,</span></span>
<span class="line"><span style="color:#C3E88D;">         800px</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">elva-fairy-800w.jpg</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#C792EA;">alt</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Elva dressed as a fairy</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;"> /&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>有了这些属性后，浏览器会：</p><ol><li>查看屏幕尺寸、像素密度、缩放级别、屏幕方向和网络速度。</li><li>找出 sizes 列表中第一个为真的媒体条件。</li><li>查看该媒体查询对应的插槽大小。</li><li>加载 srcset 列表中引用的与插槽大小相同的图片，如果没有，则加载第一个大于所选插槽大小的图片。</li></ol><blockquote><p>图片作为流式布局的一部分，请始终确保它不会超过容器的宽度。为了避免这种情况发生，一劳永逸的办法是在样式表加入规则</p></blockquote><div class="language-css line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">img</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#B2CCD6;">max-width</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100%</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div>`,213),t=[l];function r(n,i,c,d,u,h){return a(),p("div",null,t)}const x=e(o,[["render",r]]);export{m as __pageData,x as default};
