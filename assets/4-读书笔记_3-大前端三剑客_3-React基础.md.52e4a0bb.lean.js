import{_ as e,v as a,b as r,R as s}from"./chunks/framework.caa0fbaf.js";const _=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"4-读书笔记/3-大前端三剑客/3-React基础.md","filePath":"4-读书笔记/3-大前端三剑客/3-React基础.md","lastUpdated":1714802656000}'),t={name:"4-读书笔记/3-大前端三剑客/3-React基础.md"},p=s(`<p>由于工作中很少用到React，所以记录的可能详细一点，但是我看书里面很多是按照 类组件来举例的，16.8之后，应该很少使用类组件了吧，所以主要把几个hooks再回 顾一遍。</p><h2 id="一、hooks" tabindex="-1">一、Hooks <a class="header-anchor" href="#一、hooks" aria-label="Permalink to &quot;一、Hooks&quot;">​</a></h2><p>为什么使用Hooks（函数式组件）代替类组件？</p><p>(1)针对优化类组件的三大问题：状态逻辑难复用、趋向复杂难以维护、this指向问题。</p><p>(2)在无须修改组件结构的情况下复用状态逻辑（自定义Hook）。</p><p>(3)将组件中相互关联的部分拆分成更小的函数（例如设置订阅或请求数据）。</p><p>(4)副作用的关注点分离：副作用指那些没有发生在数据向视图转换过程中的逻辑，如Ajax请求、访问原生DOM元素、本地持久化缓存、绑定／解绑事件、添加订阅、设置定时器、记录日志等。这些<code>副作用</code>都写在类组件生命周期函数中。</p><p>React会保持对当前渲染组件的追踪，每个组件内部都有一个<code>记忆单元格</code>，用于存储JS对象数据。当调用Hook时就可读取当前Hook所在组件的记忆单元格里面的数据。</p><h3 id="usestate" tabindex="-1">useState <a class="header-anchor" href="#usestate" aria-label="Permalink to &quot;useState&quot;">​</a></h3><p>useState()用于为函数式组件引入状态(state)。因为纯函数不能有状态，所以把状态放在钩子里面。</p><h3 id="初始化state" tabindex="-1">初始化state <a class="header-anchor" href="#初始化state" aria-label="Permalink to &quot;初始化state&quot;">​</a></h3><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P553_26593.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P553_26593.jpg" alt="useState"></a></p><p>上面的代码会返回一个num和num的更新函数，num和setNum名称是自己定义的。在初始渲染期间，返回的状态(num)与传入的第1个参数(initialState)的值相同。setNum()函数用于更新num，它接收一个新的num值并将组件的一次重新渲染加入队列。</p><h3 id="惰性初始化state" tabindex="-1">惰性初始化state <a class="header-anchor" href="#惰性初始化state" aria-label="Permalink to &quot;惰性初始化state&quot;">​</a></h3><p>initialState参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始num需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的num，此函数只在初始渲染时被调用。</p><p>它应该是纯函数，不应该接受任何参数，并且应该返回一个任何类型的值。当初始化组件时，React 将调用你的初始化函数，并将其返回值存储为初始状态。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P554_26604.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P554_26604.jpg" alt="惰性state"></a></p><p>useState用法： <a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P554_26616.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P554_26616.jpg" alt="state"></a></p><h3 id="更新state" tabindex="-1">更新state <a class="header-anchor" href="#更新state" aria-label="Permalink to &quot;更新state&quot;">​</a></h3><p>如果新的state需要通过先前的state计算得出，则可以将<code>函数</code>传递给setState()。该<code>函数将接收先前的state</code>，并返回一个更新后的值。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P555_26786.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P555_26786.jpg" alt="更新state"></a></p><p>因为被更新的state需要基于之前的state，但是“重置”按钮则采用普通形式，因为它总是把count设置回初始值。</p><h3 id="useeffect" tabindex="-1">useEffect <a class="header-anchor" href="#useeffect" aria-label="Permalink to &quot;useEffect&quot;">​</a></h3><p>useEffect()用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前放在componentDidMount里面的代码，现在可以放在useEffect()里。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P556_26860.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P556_26860.jpg" alt="useEffect"></a></p><p>useEffect()接收两个参数。第1个参数是一个函数，异步操作的代码放在里面。第2个参数是一个数组，用于给出effect的依赖项，只要这个数组发生变化，useEffect()就会执行。第2个参数可以省略，这时每次组件渲染时，都会执行useEffect()。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P556_26872.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P556_26872.jpg" alt="useEffect"></a></p><p>组件卸载时需要清除effect创建的诸如订阅或计时器ID等资源。要实现这一点，useEffect()函数需返回一个清除函数。</p><h4 id="关注点分离" tabindex="-1">关注点分离 <a class="header-anchor" href="#关注点分离" aria-label="Permalink to &quot;关注点分离&quot;">​</a></h4><p>使用Hook其中的一个目的就是要解决class中生命周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。Hook允许按照代码的用途分离它们，而不是像生命周期函数那样。React将按照effect声明的顺序依次调用组件中的每个effect。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P559_27128.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P559_27128.jpg" alt="useEffect"></a></p><h3 id="uselayouteffect" tabindex="-1">useLayoutEffect <a class="header-anchor" href="#uselayouteffect" aria-label="Permalink to &quot;useLayoutEffect&quot;">​</a></h3><p>useLayoutEffect()函数签名与useEffect()类似，但它会在所有的DOM变更之后同步调用effect。可以使用它来读取DOM布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect()内部的更新计划将被同步刷新。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P560_27153.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P560_27153.jpg" alt="useLayoutEffect"></a></p><p>运行上面的组件，单击div按钮，页面会更新一串随机数，当连续单击此按钮时，会发现这串数字在发生抖动。造成抖动原因在于，每次单击div按钮时，count会更新为0(<code>setCount(0)</code>)，之后<code>useEffect()</code>内又把count改为一串随机数，所以页面会<code>先渲染成0</code>，然后<code>渲染成随机数</code>，由于更新很快，所以出现了<code>闪烁</code>。</p><p>接下来将useEffect()改为useLayoutEffect()后闪烁消失了。相比使用useEffect()，当单击div按钮时，count更新为0，此时页面并不会渲染，而是等待<code>useLayoutEffect()内部状态修改后才会去更新页面</code>，所以页面不会闪烁。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P560_27177.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P560_27177.jpg" alt="浏览器渲染"></a></p><p>useLayoutEffect()：会在浏览器layout之后，painting(绘制)之前执行。如果需要改变DOM或者DOM需要获取测量数值，除非要修改DOM并且不让用户看到修改DOM的过程，才考虑用它来读取DOM布局并同步触发重渲染，否则应当使用useEffect()。在浏览器执行绘制之前，useLayoutEffect()内部的更新计划将被同步刷新。尽可能使用标准的useEffect()以避免阻塞视图更新。</p><p>useEffect()：useEffect()在全部渲染完毕后才会执行。如果根本不需要与DOM交互或者DOM更改是不可观察的，那就用useEffect()。</p><h3 id="useref" tabindex="-1">useRef <a class="header-anchor" href="#useref" aria-label="Permalink to &quot;useRef&quot;">​</a></h3><p>(1)useRef()返回一个可变的ref对象，并且只有current属性，初始值为传入的参数(initialValue)。</p><p>(2)返回的ref对象在组件的整个生命周期内保持不变。</p><p>(3)当更新current值时并不会渲染，而useState()新值时会触发页面渲染。</p><p>(4)更新useRef()是Side Effect（副作用），所以一般写在useEffect()或Event Handler里。</p><p>(5)useRef()类似于类组件的this。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P561_27189.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P561_27189.jpg" alt="useRef"></a></p><h4 id="获取子组件属性或方法" tabindex="-1">获取子组件属性或方法 <a class="header-anchor" href="#获取子组件属性或方法" aria-label="Permalink to &quot;获取子组件属性或方法&quot;">​</a></h4><p>综合使用useRef()、forwardRef()、useImperativeHandle()获取子组件数据。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-T562_27293.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-T562_27293.jpg" alt="获取子组件属性或方法"></a></p><p>子组件：</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P562_27273.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P562_27273.jpg" alt="子组件"></a></p><p>父组件：</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P563_27319.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P563_27319.jpg" alt="父组件"></a></p><h4 id="使用useref-获取上一次的值" tabindex="-1">使用useRef()获取上一次的值 <a class="header-anchor" href="#使用useref-获取上一次的值" aria-label="Permalink to &quot;使用useRef()获取上一次的值&quot;">​</a></h4><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P564_27375.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P564_27375.jpg" alt="useRef"></a></p><p>useRef()函数在渲染过程中总是返回上一次的值，因为ref.current变化不会触发组件的重新渲染，所以需要等到下次渲染时才能显示到页面上。</p><h4 id="使用useref保存不需要变化的值" tabindex="-1">使用useRef保存不需要变化的值 <a class="header-anchor" href="#使用useref保存不需要变化的值" aria-label="Permalink to &quot;使用useRef保存不需要变化的值&quot;">​</a></h4><p>因为useRef()的返回值在组件的每次调用render()之后都是同一个，所以它可以用来保存一些在组件整个生命周期都不需要变化的值。最常见的就是定时器的清除场景。</p><p>全局变量设置定时器的不足:</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P564_27387.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P564_27387.jpg" alt="全局变量定时器"></a></p><p>上面的写法存在一个问题，如果这个App组件里有state变化或者它的父组件重新渲染等原因导致这个App组件重新渲染时会发现，单击“停止”按钮，定时器依然会不断地在控制台输出，这样定时器清除事件就无效了。因为组件重新渲染之后，这里的timer()及clearTimer()方法都会重新创建，所以timer已经不是定时器的变量了</p><p>使用useRef优化：</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P565_27437.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P565_27437.jpg" alt="useRef"></a></p><h3 id="usecallback、usememo与react-memo" tabindex="-1">useCallback、useMemo与React.memo <a class="header-anchor" href="#usecallback、usememo与react-memo" aria-label="Permalink to &quot;useCallback、useMemo与React.memo&quot;">​</a></h3><p>React中当组件的props或state变化时，会重新渲染视图，在实际开发中会遇到不必要的渲染场景。</p><h4 id="不必要渲染子组件" tabindex="-1">不必要渲染子组件 <a class="header-anchor" href="#不必要渲染子组件" aria-label="Permalink to &quot;不必要渲染子组件&quot;">​</a></h4><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P565_27485.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P565_27485.jpg" alt="不必要渲染"></a></p><p>子组件中有条console语句，每当子组件被渲染时，都会在控制台看到一条输出信息。当单击父组件中按钮时会修改count变量的值，进而导致父组件重新渲染，此时子组件却没有任何变化(props、state)，但在控制台中仍然可看到子组件被渲染的输出信息。</p><p>我们期待的是：当子组件的props和state没有变化时，即便父组件渲染，也不要渲染子组件。</p><h4 id="react-memo" tabindex="-1">React.memo() <a class="header-anchor" href="#react-memo" aria-label="Permalink to &quot;React.memo()&quot;">​</a></h4><p>为了解决上面的问题，需要修改子组件，用React.memo()包裹一层。这种写法是React的高阶组件写法，将组件作为函数(memo)的参数，函数的返回值(ChildComp)是一个新的组件。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P566_27567.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P566_27567.jpg" alt="React.memo()"></a></p><p>此时再次单击按钮，可以看到控制台没有输出子组件被渲染的信息了。</p><h4 id="usecallback" tabindex="-1">useCallBack() <a class="header-anchor" href="#usecallback" aria-label="Permalink to &quot;useCallBack()&quot;">​</a></h4><p>在上面的例子中，父组件只是简单地调用了子组件，并未给子组件传递任何属性。接下来看一个父组件给子组件传递属性的例子，子组件仍然用React.memo()包裹一层。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P567_27595.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P567_27595.jpg" alt="useCallback()"></a></p><p>父组件在调用子组件时传递了name属性和onClick属性，此时单击父组件的按钮，可以看到控制台中输出了子组件被渲染的信息。</p><p>在上面的代码中，子组件通过React.memo()包裹了，但是子组件还是重新渲染了。</p><p>分析下原因：</p><p>(1)单击父组件按钮，改变了父组件中count变量值（父组件的state值），进而导致父组件重新渲染。</p><p>(2)父组件重新渲染时，会重新创建changeName()函数，即传给子组件的onClick属性发生了变化，从而导致子组件重新渲染。只是单击了父组件的按钮，并未对子组件做任何操作，并且不希望子组件的props有变化。</p><p>为了解决这个问题，可以使用useCallback()钩子完善代码。首先修改父组件的changeName()方法，用useCallback()钩子函数包裹一层。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P568_27687.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P568_27687.jpg" alt="useCallback()"></a></p><p>上面的代码修改后，此时单击父组件按钮，控制台不会输出子组件被渲染的信息了。</p><p>useCallback()起到了<code>缓存的作用</code>，即便父组件渲染了，useCallback()包裹的函数也不会重新生成，只会返回上一次的函数引用。</p><p>useCallback的第二个参数，是一个dependencies数组，参考useEffcet的第二个参数。</p><h4 id="usememo" tabindex="-1">useMemo <a class="header-anchor" href="#usememo" aria-label="Permalink to &quot;useMemo&quot;">​</a></h4><p>前面父组件调用子组件时传递的name属性是个字符串，如果换成<code>传递对象</code>会怎样？</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P569_27741.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P569_27741.jpg" alt="传递属性为对象"></a></p><p>父组件在调用子组件时传递info属性，info的值是个对象字面量，单击父组件按钮时，发现控制台输出子组件被渲染的信息。</p><p>分析原因跟调用函数是一样的：当单击父组件按钮时，触发父组件重新渲染；父组件渲染，代码const info={name,age}会<code>重新生成一个新对象</code>，导致传递给子组件的<code>info属性值</code>变化，进而导致子组件重新渲染。</p><p>针对这种情况，可以使用useMemo()对对象属性包裹一层。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P569_27784.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P569_27784.jpg" alt="useMemo"></a></p><p>useMemo()有两个参数：</p><p>(1)第1个参数是个函数，返回的对象指向同一个引用，不会创建新对象。</p><p>(2)第2个参数是个数组，只有<code>数组中的变量改变</code>时，第1个参数的函数才会<code>返回一个新的对象</code>。</p><p>当再次单击父组件按钮时，控制台中不再输出子组件被渲染的信息了。</p><h3 id="usecontext" tabindex="-1">useContext <a class="header-anchor" href="#usecontext" aria-label="Permalink to &quot;useContext&quot;">​</a></h3><p>在Hook诞生之前，React已经有了在组件树中共享数据的解决方案：Context。</p><p>在类组件中，可以通过Class.contextType属性获取最近的Context Provider，那么在函数式组件中，该怎么获取呢？</p><p>答案就是使用<code>useContext()</code>钩子</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P571_27893.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P571_27893.jpg" alt="useContext"></a></p><p>useContext()的使用步骤如下。</p><p>(1)封装公共上下文对象文件。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P571_27902.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P571_27902.jpg" alt="useContext用法"></a></p><p>(2)在父组件中通过myContext<code>提供器Provider为子组件提供value数据</code>。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P571_27910.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P571_27910.jpg" alt="myContext"></a></p><p>(3)在子组件中<code>导入myContext对象</code>，使用<code>useContext()</code>获取共享数据。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P572_27998.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P572_27998.jpg" alt="子组件共享context"></a></p><h3 id="usereducer" tabindex="-1">useReducer() <a class="header-anchor" href="#usereducer" aria-label="Permalink to &quot;useReducer()&quot;">​</a></h3><p>useReducer()函数可提供类似Redux的功能，可以理解为轻量级的Redux。useReducer()接收一个reducer()函数作为参数和一个初始化的状态值。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P572_28046.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P572_28046.jpg" alt="useReducer"></a></p><p>去react官网看了一下，这个useReducer其实可以有第三个参数。</p><div class="language-tsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#82AAFF;">useReducer</span><span style="color:#A6ACCD;">(reducer</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> initialArg</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> init</span><span style="color:#89DDFF;">?</span><span style="color:#A6ACCD;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>reducer：用于更新 state 的纯函数。参数为 state 和 action，返回值是更新后的 state。state 与 action 可以是任意合法值。</p><p>initialArg：用于初始化 state 的任意值。初始值的计算逻辑取决于接下来的 init 参数。</p><p>可选参数 init：用于计算初始值的函数。如果存在，使用 init(initialArg) 的执行结果作为初始值，否则使用 initialArg。</p><p>useReducer()函数返回一个数组，数组的第一项为状态变量，dispatch是发送事件的方法，用法与Redux是一样的。</p><p>reducer()是一个函数，该函数根据动作类型处理状态。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P573_28057.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P573_28057.jpg" alt="reducer"></a></p><p>完整useReducer()用法： <a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P573_28065.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P573_28065.jpg" alt="useReducer"></a></p><p>在React中，如果你想在使用useReducer时传递额外的参数给dispatch函数以修改state，你可以通过创建一个带有参数的函数，然后将其传递给dispatch。以下是一种方法：</p><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> React</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">useReducer</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">react</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 定义 reducer 函数</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> reducer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">state</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">action</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">switch</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">action</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">type</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">case</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">INCREMENT</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> count</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">action</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#89DDFF;">:</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> Counter </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 初始 state</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">initialState</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> count</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">0</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 使用 useReducer</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">dispatch</span><span style="color:#89DDFF;">]</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">useReducer</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">reducer</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">initialState</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 定义一个函数，用于传递额外的参数给 dispatch</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">incrementCount</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">value</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">dispatch</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> type</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">INCREMENT</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">value</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      Count: </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;">state</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">count</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">{</span><span style="color:#676E95;font-style:italic;">/* 调用函数并传递额外的参数 */</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">onClick</span><span style="color:#89DDFF;">={()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">incrementCount</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">5</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">}&gt;</span><span style="color:#A6ACCD;">Increment</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">button</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">  )</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> Counter</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><h3 id="自定义hooks" tabindex="-1">自定义Hooks <a class="header-anchor" href="#自定义hooks" aria-label="Permalink to &quot;自定义Hooks&quot;">​</a></h3><p>自定义Hook的主要目的是重用组件中使用的逻辑。构建自己的Hook可以让开发者将组件逻辑提取到可重用的函数中。</p><p>自定义Hook是常规的JavaScript函数，可以使用任何其他Hook，只要它们遵循Hook的规则。</p><p>此外，自定义Hook的名称必须以单词use开头。</p><h4 id="usecounter" tabindex="-1">useCounter <a class="header-anchor" href="#usecounter" aria-label="Permalink to &quot;useCounter&quot;">​</a></h4><p>实现一个计数器应用，它的值可以递增、递减或重置。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P574_28231.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P574_28231.jpg" alt="custom hooks"></a></p><p>使用useCounter:</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P575_28267.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P575_28267.jpg" alt="使用useCounter"></a></p><p>通过这种方式可以将App组件的状态及其操作完全提取到useCounter Hook中，管理计数器状态和逻辑现在是自定义Hook的责任。</p><h4 id="usefield" tabindex="-1">useField <a class="header-anchor" href="#usefield" aria-label="Permalink to &quot;useField&quot;">​</a></h4><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P577_28498.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P577_28498.jpg" alt="useField"></a></p><p>使用useField:</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P578_28516.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P578_28516.jpg" alt="使用useField"></a></p><p>简化：</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P578_28559.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P578_28559.jpg" alt="简化"></a></p><p>表单中使用：</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P578_28591.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P578_28591.jpg" alt="表单中使用useField"></a></p><p>当与同步表单状态有关的恼人的细节被封装在自定义Hook中时，表单的处理就大大简化了。自定义Hook显然不仅是一种可重用的工具，它们还为将代码划分为更小的模块提供了一种更好的方式。</p><h2 id="二、路由react-router" tabindex="-1">二、路由React Router <a class="header-anchor" href="#二、路由react-router" aria-label="Permalink to &quot;二、路由React Router&quot;">​</a></h2><p>React Router库是React官方配套的路由模块，目前最新的版本是v6,v6版本和之前的版本比较有了较大的改进。在v6版本的路由中在外层统一配置路由结构，让路由结构更清晰，通过Outlet实现子代路由的渲染，在一定程度上有点类似于Vue中的view-router。</p><p>React Router中包含3个不同的模块，每个包都有不同的用途。官方网址为<a href="https://reactrouter.com/docs/en/v6/api" target="_blank" rel="noreferrer">https://reactrouter.com/docs/en/v6/api</a></p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-T579_43460.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-T579_43460.jpg" alt="React Router"></a></p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P580_28708.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P580_28708.jpg" alt="React Router模块"></a></p><h4 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h4><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">install</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">react-router-dom@6</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">yarn</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">add</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">react-router-dom@6</span></span>
<span class="line"></span>
<span class="line"><span style="color:#FFCB6B;">pnpm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">add</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">react-router-dom@6</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="路由模式" tabindex="-1">路由模式 <a class="header-anchor" href="#路由模式" aria-label="Permalink to &quot;路由模式&quot;">​</a></h3><p>react-router-dom支持两种模式路由：HashRouter和BrowserRouter。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-T580_43464.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-T580_43464.jpg" alt="react router"></a></p><p>使用React Router:</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P581_28755.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P581_28755.jpg" alt="react router"></a></p><p>v6版本路由采用了Router→Routes→Route结构，路由本质在于Routes组件，当location上下文改变时，Routes重新渲染，重新形成渲染分支，然后通过Provider方式逐层传递Outlet，进行匹配渲染。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-T581_43468.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-T581_43468.jpg" alt="react router"></a></p><p>为了更好地支持Hook用法，v6版本中提供了路由Hook:</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-T582_29037.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-T582_29037.jpg" alt="react router hook"></a></p><h4 id="使用" tabindex="-1">使用 <a class="header-anchor" href="#使用" aria-label="Permalink to &quot;使用&quot;">​</a></h4><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P582_28971.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P582_28971.jpg" alt="react router使用"></a></p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P582_29011.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P582_29011.jpg" alt="App.js"></a></p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P583_29121.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P583_29121.jpg" alt="Home.jsAbount.js"></a></p><h3 id="嵌套路由" tabindex="-1">嵌套路由 <a class="header-anchor" href="#嵌套路由" aria-label="Permalink to &quot;嵌套路由&quot;">​</a></h3><p>嵌套模式路由是一个很重要的概念，当路由被嵌套时，一般认为网页的某一部分保持不变，只有网页的子部分发生变化。</p><p>例如，如果访问一个简单的用户管理页面，则始终显示该用户的标题，然后在其下方显示用户的详细信息，但是，当单击修改用户时，用户详情页将替换为用户修改页面。在React Router v5中，必须明确定义嵌套模式路由，React Router v6更加简单。React Router库中的Outlet组件可以为特定路由呈现任何匹配的子元素。首先，从react-router-dom库中导入Outlet，代码如下：</p><div class="language-tsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">tsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Outlet</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">react-router-dom</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在父组件(User.js)中使用Outlet组件，该组件用来显示匹配子路由的页面。</p><p>User.js:</p><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">User</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> (</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">User</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">h1</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Outlet</span><span style="color:#89DDFF;"> /&gt;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">div</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"><span style="color:#F07178;">  )</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>定义嵌套模式路由(Route中嵌套Route组件)，在嵌套模式路由中，如果URL仅匹配了父级URL，则Outlet中会显示带有index属性的路由。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P585_29304.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P585_29304.jpg" alt="嵌套路由"></a></p><p>当URL为/user时，User中的Outlet会显示Default组件。</p><p>当URL为/user/create时，User中的Outlet会显示NewUser组件。</p><h3 id="路由参数" tabindex="-1">路由参数 <a class="header-anchor" href="#路由参数" aria-label="Permalink to &quot;路由参数&quot;">​</a></h3><p>下面介绍两种获取路由参数的方式，即获取params参数的方式和获取search参数的方式。</p><h4 id="param参数" tabindex="-1">param参数 <a class="header-anchor" href="#param参数" aria-label="Permalink to &quot;param参数&quot;">​</a></h4><p>在Route组件的path属性中定义路径参数，在组件内通过useParams钩子访问路径参数。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P585_29421.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P585_29421.jpg" alt="useParam"></a></p><h4 id="search参数" tabindex="-1">search参数 <a class="header-anchor" href="#search参数" aria-label="Permalink to &quot;search参数&quot;">​</a></h4><p>和vue router中的query差不多。</p><p>查询参数不需要在路由中定义。使用useSearchParams钩子访问查询参数，其用法和useState类似，会返回当前对象和更改它的方法。更改searchParams时，必须传入所有的查询参数，否则会覆盖已有参数。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P586_29490.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P586_29490.jpg" alt="useSearch"></a></p><h3 id="编程式路由导航" tabindex="-1">编程式路由导航 <a class="header-anchor" href="#编程式路由导航" aria-label="Permalink to &quot;编程式路由导航&quot;">​</a></h3><p>在React Router v6中，编程式路由导航用<code>useNavigate</code>代替<code>useHistory</code>，将<code>history.push()</code>替换为<code>navigation()</code>。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P586_29513.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P586_29513.jpg" alt="编程式路由导航"></a></p><h3 id="多个-routes" tabindex="-1">多个 <code>&lt;Routes /&gt;</code> <a class="header-anchor" href="#多个-routes" aria-label="Permalink to &quot;多个 \`&lt;Routes /&gt;\`&quot;">​</a></h3><p>以前只能在React App中使用一个路由，但是现在可以在React App中使用多个路由，这将帮助我们基于不同的路由管理多个应用程序逻辑。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P587_29543.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P587_29543.jpg" alt="多个Routes"></a></p><h2 id="三、redux" tabindex="-1">三、Redux <a class="header-anchor" href="#三、redux" aria-label="Permalink to &quot;三、Redux&quot;">​</a></h2><p>随着React开发的组件的结构越来越复杂，深层的组件嵌套和组件树中的状态流动会变得难以控制，跟踪和测试节点的state流动到子节点时产生的变化越发困难。这个时候就需要进行状态管理了。为了解决组件树的状态管理的问题，React推出了Flux数据流管理框架。</p><p>Flux本身是一个架构思想，它最重要的概念是单向数据流，是将应用中的state进行统一管理，通过发布／订阅模式进行状态的更新与传递。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P588_29646.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P588_29646.jpg" alt="Flux"></a></p><p>Flux带来一些问题，如一个应用可以拥有多个Store，多个Store之间可能有依赖关系，也可能相互引用，Store封装了数据和处理数据的逻辑。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P588_29649.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P588_29649.jpg" alt="Flux"></a></p><p>目前社区出现了一系列的前端状态管理解决方案，如遵循Flux思想的状态管理方案主要有Redux、Vuex、Zustand及React自带的useReducer+Context。</p><h3 id="redux介绍" tabindex="-1">Redux介绍 <a class="header-anchor" href="#redux介绍" aria-label="Permalink to &quot;Redux介绍&quot;">​</a></h3><p>Redux是目前最热门的状态管理库之一，它受到Elm的启发，是从Flux单项数据流架构演变而来的。</p><p>Redux的核心基于发布和订阅模式。View订阅了Store的变化，一旦Store状态发生改变就会通知所有的订阅者，View接收到通知之后会进行重新渲染。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P588_29654.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P588_29654.jpg" alt="Redux"></a></p><p>Redux遵循Flux思想，Redux将状态以一个可JSON序列化的对象的形式存储在单个Store中，也就是说Redux将状态集中存储。Redux采用单向数据流的形式，如果要修改Store中的状态，则必须通过Store的dispatch()方法。调用store.dispatch()之后，Store中的rootReducer()会被调用，进而调用所有的Reducer()函数生成一个新的state。</p><h3 id="redux的基本原则" tabindex="-1">Redux的基本原则 <a class="header-anchor" href="#redux的基本原则" aria-label="Permalink to &quot;Redux的基本原则&quot;">​</a></h3><p>(1)单一数据源：整个应用的state被储存在一棵对象树中，并且这个对象树只存在于唯一一个Store中。</p><p>(2)state是只读的：唯一改变state的方法就是<code>触发Action</code>,Action是一个用于描述已发生事件的普通对象。</p><p>(3)使用纯函数来执行修改：为了描述Action如何改变状态树，需要编写<code>Reducer()函数</code>。</p><h3 id="核心组成" tabindex="-1">核心组成 <a class="header-anchor" href="#核心组成" aria-label="Permalink to &quot;核心组成&quot;">​</a></h3><p>Redux的核心组成部分包括Action、Reducer、Store。</p><p>(1)Action:Action就是一个描述发生什么的对象。</p><p>(2)Reducer：形式为(state,action)=&gt;state的纯函数，功能是根据Action修改state并将其转变成下一个state。</p><p>(3)Store：用于存储state，可以把它看成一个容器，整个应用只能有一个Store。</p><p>Redux应用中所有的state都以一个对象树的形式储存在一个单一的Store中。唯一改变state的办法是触发Action,Action就是一个描述发生什么的对象。为了描述Action如何改变state树，需要编写Reducer()函数。</p><h3 id="redux基本用法" tabindex="-1">Redux基本用法 <a class="header-anchor" href="#redux基本用法" aria-label="Permalink to &quot;Redux基本用法&quot;">​</a></h3><h4 id="安装-1" tabindex="-1">安装 <a class="header-anchor" href="#安装-1" aria-label="Permalink to &quot;安装&quot;">​</a></h4><p>Redux是通用的状态框架，如果在React中使用Redux，则需要单独安装react-redux插件:</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">i</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--save</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">redux</span></span>
<span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">i</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--save</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">react-redux</span></span>
<span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">i</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--save--dev</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">redux-devtools</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Redux的官方网站为<a href="https://github.com/reduxjs/redux%E5%92%8Chttps://redux.js.org/%E3%80%82" target="_blank" rel="noreferrer">https://github.com/reduxjs/redux和https://redux.js.org/。</a></p><h4 id="创建store" tabindex="-1">创建Store <a class="header-anchor" href="#创建store" aria-label="Permalink to &quot;创建Store&quot;">​</a></h4><p>创建状态管理仓库是Redux的第一步，在Redux的API中提供一个createStore()方法，该方法接收一个reducer和一个可选middleware中间件参数。</p><p>如果把Store比作一个仓库，则Reducer就是这个仓库的管理中心，一个仓库可以根据不同的状态类型(state)设置多个不同的状态管理中心(Reducer)，每个Reducer负责根据开发者的业务需求来处理仓库中的原始状态，并返回新的状态。Reducer实际上就是一个处理state的函数，该函数中设置了很多条件，这些条件是开发者根据具体的业务设置的，不同的条件请求处理不同的状态更新。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P590_29681.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P590_29681.jpg" alt="创建store"></a></p><h4 id="提交action和订阅store" tabindex="-1">提交Action和订阅Store <a class="header-anchor" href="#提交action和订阅store" aria-label="Permalink to &quot;提交Action和订阅Store&quot;">​</a></h4><p>创建好状态管理仓库后，创建一个React组件，在组件中订阅仓库的状态，组件中通过dispatch()方法给仓库发送事件以便更新仓库状态。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P590_29695.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P590_29695.jpg" alt="使用store"></a></p><p>在上面的代码中，在useEffect()方法中，订阅获取Store中最新的状态，单击按钮，通过store.dispatch({type:&#39;ADD&#39;})将动作类型发送给Store中的Reducer处理，并返回最新的状态。</p><h4 id="使用react-redux绑定store" tabindex="-1">使用react-redux绑定store <a class="header-anchor" href="#使用react-redux绑定store" aria-label="Permalink to &quot;使用react-redux绑定store&quot;">​</a></h4><p>在上面的步骤中，手动订阅了仓库，但是这样比较麻烦，Redux官方提供了一个react-redux库，帮助我们在React中使用Redux。</p><p>react-redux提供一个高阶组件Connect,connect()方法接收一个木偶组件（无状态组件）并通过mapStateToProps（把store的状态绑定到木偶组件的props上）和mapDispatchToProps（把dispatch绑定到木偶组件中的props上）把组件和仓库进行绑定，无须开发者进行手动订阅和取消订阅。</p><p>首先，需要把ReduxDemo组件改造为木偶组件，将里面的num和单击事件更改为从外部传入props，保证组件是无状态的。</p><p>把reduxdemo组件改为木偶组件：</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P591_29769.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P591_29769.jpg" alt="木偶组件"></a></p><p>通过Connect高阶组件将上面的组件转换为连接Store的智能组件。mapStateToProps把仓库中的state映射到num上，mapDispatchToProps把onAddClick映射到dispatch()方法上：</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P591_29813.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P591_29813.jpg" alt="connect"></a></p><p>修改render入口，需要添加react-redux提供的一个组件<code>Provider</code>，通过Provider<code>属性store</code>绑定<code>创建的仓库</code>:</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P592_29843.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P592_29843.jpg" alt="render入口"></a></p><h3 id="redux核心对象" tabindex="-1">Redux核心对象 <a class="header-anchor" href="#redux核心对象" aria-label="Permalink to &quot;Redux核心对象&quot;">​</a></h3><h4 id="action" tabindex="-1">Action <a class="header-anchor" href="#action" aria-label="Permalink to &quot;Action&quot;">​</a></h4><p>动作对象，用来描述一个动作，一般包含以下两个属性。</p><p>(1)type：标识属性，值为字符串，唯一、必要属性。</p><p>(2)data：数据属性，值类型任意，可选属性。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P592_29883.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P592_29883.jpg" alt="action"></a></p><h4 id="action-creators" tabindex="-1">Action Creators <a class="header-anchor" href="#action-creators" aria-label="Permalink to &quot;Action Creators&quot;">​</a></h4><p>考虑到对它的复用，Action可以通过生成器(ActionCreators)来创建。其实它就是返回Action对象的函数（自定义的函数）。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P593_29895.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P593_29895.jpg" alt="actionCreators"></a></p><h4 id="reducer" tabindex="-1">Reducer <a class="header-anchor" href="#reducer" aria-label="Permalink to &quot;Reducer&quot;">​</a></h4><p>Reducer的本质就是一个纯函数，它用来响应发送过来的Actions，然后经过处理把state发送给Store。在Reducer函数中通过return返回值，这样Store才能接收到数据，Reducer会接收到两个参数，一个是初始化的state，另一个则是发送过来的Action。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P593_29903.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P593_29903.jpg" alt="reducer"></a></p><h4 id="combinereducers" tabindex="-1">combineReducers() <a class="header-anchor" href="#combinereducers" aria-label="Permalink to &quot;combineReducers()&quot;">​</a></h4><p>真正开发项目时state涉及很多功能，在一个Reducer中处理所有逻辑会非常混乱，所以需要拆分成多个小Reducer，每个Reducer只处理它管理的那部分state数据，然后再由一个主rootReducers来专门管理这些小Reducer。</p><p>Redux提供了一种方法combineReducers()专门来管理这些小Reducer。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P594_29914.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P594_29914.jpg" alt="combineReducers()"></a></p><h4 id="store" tabindex="-1">Store <a class="header-anchor" href="#store" aria-label="Permalink to &quot;Store&quot;">​</a></h4><p>Store用于存储应用中所有组件的state状态，也代表着组件状态的数据模型，它提供统一的API方法来对state进行读取、更新、监听等操作。</p><p>Store本身是一个对象，在Redux应用中Store具有单一性，并且通过向createStore()函数中传入Reducer来创建Store。其另一个重要作用就是作为连接Action与Reducer的桥梁。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P594_29922.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P594_29922.jpg" alt="store"></a></p><h3 id="redux中间件" tabindex="-1">Redux中间件 <a class="header-anchor" href="#redux中间件" aria-label="Permalink to &quot;Redux中间件&quot;">​</a></h3><p>Redux的中间件(Middleware)遵循了即插即用的设计思想，出现在Action到达Reducer之前的位置。</p><p>中间件是一个具有固定模式的独立函数，当把多个中间件像管道那样串联在一起时，前一个中间件不但能将其输出传给下一个中间件作为输入，还能中断整条管道。</p><p>在引入中间件后，既能扩展Redux的功能，也能增强dispatch()函数的功能，以适应不同的业务需求，例如通过中间件记录日志、报告奔溃或处理异步请求等。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P594_29927.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P594_29927.jpg" alt="中间件"></a></p><h4 id="中间件接口" tabindex="-1">中间件接口 <a class="header-anchor" href="#中间件接口" aria-label="Permalink to &quot;中间件接口&quot;">​</a></h4><p>在设计中间件函数时，会遵循一个固定的模式，下面的代码使用了柯里化、高阶函数等函数式编程的概念：</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P594_29935.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P594_29935.jpg" alt="中间件"></a></p><p>ES6语法：</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P595_29945.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P595_29945.jpg" alt="中间件"></a></p><p>middleware()函数接收一个Store实例，返回值是一个接收next参数的函数，其中next也是一个函数，用来将控制权转移给下一个中间件，从而实现中间件之间的串联，它会返回一个处理Action对象的函数。</p><p>由于闭包的作用，在这最内层的函数中，依然能调用外层的对象和函数，例如访问Action所携带的数据、执行<code>Store中的dispatch()或getState()方法</code>等。</p><p>示例中的middleware()函数只是单纯地将接收的action对象<code>转交</code>给后面的中间件，而没有对其做额外的处理。</p><h4 id="创建一个日志中间件" tabindex="-1">创建一个日志中间件 <a class="header-anchor" href="#创建一个日志中间件" aria-label="Permalink to &quot;创建一个日志中间件&quot;">​</a></h4><p>该中间件，打印组件发送过来的Action，延迟1s，重构一个新的Action交给Reducer处理。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P595_29963.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P595_29963.jpg" alt="日志中间件"></a></p><h4 id="注册中间件" tabindex="-1">注册中间件 <a class="header-anchor" href="#注册中间件" aria-label="Permalink to &quot;注册中间件&quot;">​</a></h4><p>中间件在开发完成以后只有被注册才能在Redux的工作流程中生效，Redux中有个applyMiddleware，其作用是注册中间件。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P595_29984.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P595_29984.jpg" alt="注册中间件"></a></p><h3 id="redux中间件-redux-thunk" tabindex="-1">Redux中间件（redux-thunk） <a class="header-anchor" href="#redux中间件-redux-thunk" aria-label="Permalink to &quot;Redux中间件（redux-thunk）&quot;">​</a></h3><p>如果要在Redux中处理异步请求，则可以借助中间件实现。目前市面上已有很多封装好的中间件可供使用，例如redux-thunk、redux-promise或redux-saga等。redux-thunk是一个非常简单的中间件。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P596_29996.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P596_29996.jpg" alt="redux-thunk"></a></p><p>首先检测Action的类型，如果是函数，就直接调用并将dispatch、getState和extraArgument作为参数传入，否则就调用next参数，转移控制权。redux-thunk其实扩展了dispatch()方法，使其参数既可以是JavaScript对象，也可以是函数。</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">npm</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">install</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">redux-thunk</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">--save</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P596_30022.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P596_30022.jpg" alt="使用redux-thunk"></a></p><p>派发异步事件：</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P597_30050.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P597_30050.jpg" alt="派发异步事件"></a></p><p>index.js</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P598_30128.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P598_30128.jpg" alt="index.js"></a></p><h3 id="redux中间件-redux-saga" tabindex="-1">Redux中间件（redux-saga） <a class="header-anchor" href="#redux中间件-redux-saga" aria-label="Permalink to &quot;Redux中间件（redux-saga）&quot;">​</a></h3><p>redux-saga是一个用于管理应用程序Side Effect（副作用，如异步获取数据、访问浏览器缓存等）的库，它的目标是让副作用管理更容易，执行更高效，测试更简单，在处理故障时更容易。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P599_30166.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P599_30166.jpg" alt="redux-saga"></a></p><p>redux-saga是一个用于管理Redux应用异步操作的中间件（又称异步Action）。</p><p>redux-saga通过创建Saga将所有的异步操作逻辑收集在一个地方集中处理，用来代替redux-thunk中间件。通过redux-saga库来处理副作用相关操作，Redux的各部分的协作更明确：</p><p>(1)Reducer负责处理Action的state更新。</p><p>(2)Saga负责协调那些复杂或异步的操作。</p><p>Saga不同于Thunk,Thunk是在Action被创建时调用，而Saga只会在应用启动时调用，初始启动的Saga可能会动态调用其他Saga,Saga可以被看作在后台运行的进程，Saga监听发起Action，然后决定基于这个Action来做什么：是发起一个异步调用（如一个fetch请求），还是发起其他的Action到Store，甚至是调用其他的Saga。</p><p>Saga是通过Generator()函数来创建的，所有的任务都通用Yield Effect来完成。Effect可以看作redux-saga的任务单元，Effects都是简单的JavaScript对象，包含要被Saga Middleware执行的信息，redux-saga为各项任务提供了各种Effect创建器，例如调用一个异步函数，发起一个Action到Store，启动一个后台任务或者等待一个满足某些条件的未来的Action。</p><p>内部是使用了yield函数，有点看不懂这部分的内容，gannerator函数用的也比较少，暂时不了解了。</p><p>可以参考<a href="https://github.com/redux-saga/redux-saga" target="_blank" rel="noreferrer">redux-saga</a>。</p><p>// TODO</p><h3 id="redux-toolkit" tabindex="-1">Redux Toolkit <a class="header-anchor" href="#redux-toolkit" aria-label="Permalink to &quot;Redux Toolkit&quot;">​</a></h3><p>Redux Toolkit包是Redux的工具集，旨在解决以下问题：</p><p>(1)Store的配置复杂。</p><p>(2)想让Redux更加好用，不需要安装大量的额外包。</p><p>(3)Redux要求写很多模板代码。</p><h4 id="configurestore" tabindex="-1">configureStore <a class="header-anchor" href="#configurestore" aria-label="Permalink to &quot;configureStore&quot;">​</a></h4><p>提供简化的配置选项和良好的默认值。它可以自动组合众多的Reducer()，添加用户提供的任何Redux中间件，默认情况下包括redux-thunk（处理异步Action的中间件），并支持使用Redux DevTools扩展。</p><h4 id="createreducer" tabindex="-1">createReducer <a class="header-anchor" href="#createreducer" aria-label="Permalink to &quot;createReducer&quot;">​</a></h4><p>创建reducer()的Action映射表而不必编写switch语句。</p><p>自动使用<code>Immer库</code>让开发者用正常的代码编写更简单的不可变更新，例如state.todos[3].completed=true。</p><h4 id="createaction" tabindex="-1">createAction <a class="header-anchor" href="#createaction" aria-label="Permalink to &quot;createAction&quot;">​</a></h4><p>为给定的操作类型字符串生成action Creator()函数。</p><h4 id="createslice" tabindex="-1">createSlice <a class="header-anchor" href="#createslice" aria-label="Permalink to &quot;createSlice&quot;">​</a></h4><p>为给定的操作类型字符串生成action Creator()函数。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P607_30447.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P607_30447.jpg" alt="createSlice"></a></p><h4 id="createasyncthunk" tabindex="-1">createAsyncThunk <a class="header-anchor" href="#createasyncthunk" aria-label="Permalink to &quot;createAsyncThunk&quot;">​</a></h4><p>接收Action字符串和返回Promise的函数，并生成分派的thunk()函数。</p><h4 id="createentityadapter" tabindex="-1">createEntityAdapter <a class="header-anchor" href="#createentityadapter" aria-label="Permalink to &quot;createEntityAdapter&quot;">​</a></h4><p>生成可重用的Reducer和Selector来管理Store中的数据，执行CRUD操作。</p><h4 id="createslector" tabindex="-1">createSlector <a class="header-anchor" href="#createslector" aria-label="Permalink to &quot;createSlector&quot;">​</a></h4><p>来自Reselect库，被重新导出，用于state缓存，防止不必要的计算。</p><h4 id="redux-toolkit用法" tabindex="-1">redux-toolkit用法 <a class="header-anchor" href="#redux-toolkit用法" aria-label="Permalink to &quot;redux-toolkit用法&quot;">​</a></h4><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P608_30498.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P608_30498.jpg" alt="redux-toolkit"></a></p><ol><li>创建一个src/app/store.js文件，从Redux Toolkit里引入configureStore，将从创建和导出一个空的Redux Store开始:</li></ol><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P609_30513.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P609_30513.jpg" alt="redux-toolkit"></a></p><ol start="2"><li>一旦Store创建完成，就可以在src/index.js文件中用react-redux提供的<code>&lt;Provider&gt;</code>包裹应用，这样就可以在React组件中使用React Store了。具体操作就是先引入刚刚创建的Redux Store，然后用<code>&lt;Provider&gt;</code>包裹<code>&lt;App&gt;</code>，再将Store作为一个props传入:</li></ol><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P609_30539.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P609_30539.jpg" alt="index.js"></a></p><ol start="3"><li>创建一个src/features/counter/counterSlice.js文件，在文件里从Redux Toolkit中引入createSlice API。Slice需要一个Name作为唯一标识，需要有初始化State值，还需要至少一个reducer方法来定义State如何变化。</li></ol><p>一旦Slice创建完成就可以导出生成的Redux actioncreators和整个Slice的reducer方法。</p><p>Redux需要通过制作数据副本和更新副本来不可变地更新State，然而Redux Toolkit的createSlice和createReducer API内部使用了Immer，这允许可以直接更新逻辑，不必制作副本，它将自动成为正确的不可变更新。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P610_30570.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P610_30570.jpg" alt="redux"></a></p><ol start="4"><li>将Slice Reducer()添加进Store</li></ol><p>接下来需要引入Counter Slice的<code>reducer()</code>方法并把它添加到Store中。通过在reducer()方法中定义一个属性，告诉Store使用这个Slice Reducer()方法去处理所有的state更新。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P610_30593.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P610_30593.jpg" alt="reducer"></a></p><ol start="5"><li>在React组件中使用Redux State和Action 现在可以使用react-redux钩子在React组件中操作ReduxStore。可以使用<code>useSelector</code>从Store中读取数据，也可以使用<code>useDispatch</code>来派发Action。</li></ol><p>使用useSelector()和useDispatch()Hook来替代connect()。</p><p>传统的React应用在与Redux进行连接时通过react-redux库的connect()函数来传入mapState()和mapDispatch()函数以便将Redux中的State和Action存储到组件的props中。</p><p>react-redux新版已经支持useSelector()和useDispatchHook()，可以使用它们替代connect()的写法。通过它们可以在纯函数式组件中获取Store中的值并监测变化。</p><p>创建一个<code>src/features/counter/Counter.js</code>文件，并且在其中开发Counter组件，然后在App.js文件中引入这个组件，并且在<code>&lt;App&gt;</code>里渲染它。</p><p><a href="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P611_30610.jpg" target="_blank" rel="noreferrer"><img src="https://res.weread.qq.com/wrepub/CB_3300054198_Figure-P611_30610.jpg" alt="app.js"></a></p><h2 id="四、状态管理-recoil" tabindex="-1">四、状态管理（Recoil） <a class="header-anchor" href="#四、状态管理-recoil" aria-label="Permalink to &quot;四、状态管理（Recoil）&quot;">​</a></h2><p>不看了，这个react的生态未免有点太<code>丰富</code>了吧？😵</p><p>在React Europe 2020 Conference上，Facebook内部开源了一种状态管理库Recoil。Recoil是Facebook推出的一个全新的、实验性的JavaScript状态管理库，它解决了使用现有Context API在构建较大应用时所面临的很多问题。</p><p>还是大致看了一下，emmmm…… 感觉和pinia的原子化思想一样，然后2020才开源，感觉，唉，前端真的迭代也太快了，总是有更好的解决方法，但是你用redux时，难道没有感觉到很难用吗，额，八股文写完了，又有新的概念出现……</p><p>看了这个redux，才知道pinia有多香啊！！！！！</p><h2 id="react-native" tabindex="-1">React Native <a class="header-anchor" href="#react-native" aria-label="Permalink to &quot;React Native&quot;">​</a></h2><p>毕设用这个写的移动端，当时也没有深入了解，感觉主要是打包到原生的配置比较复杂，暂时不记录了，简单了解一下吧……</p>`,341),o=[p];function n(l,c,u,i,d,h){return a(),r("div",null,o)}const b=e(t,[["render",n]]);export{_ as __pageData,b as default};
