import{_ as s,v as a,b as n,R as l}from"./chunks/framework.caa0fbaf.js";const D=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[{"level":3,"title":"默认网络","slug":"默认网络","link":"#默认网络","children":[]},{"level":2,"title":"bridge网络模型","slug":"bridge网络模型","link":"#bridge网络模型","children":[]},{"level":2,"title":"网段冲突","slug":"网段冲突","link":"#网段冲突","children":[]}],"relativePath":"views/docker/04_network.md","filePath":"views/docker/04_network.md","lastUpdated":1695563543000}'),e={name:"views/docker/04_network.md"},p=l(`<p>当项目大规模使用 Docker 时，容器通信的问题也就产生了。要解决容器通信问题，必须先了解很多关于网络的知识。Docker 作为目前最火的轻量级容器技术，有很多令人称道的功能，如 Docker 的镜像管理。</p><p>然而，Docker 同样有着很多不完善的地方，网络方面就是 Docker 比较薄弱的部分。因此，我们有必要深入了解 Docker 的网络知识，以满足更高的网络需求。</p><h3 id="默认网络" tabindex="-1">默认网络 <a class="header-anchor" href="#默认网络" aria-label="Permalink to &quot;默认网络&quot;">​</a></h3><p>安装 Docker 以后，会默认创建三种网络，可以通过 docker network ls 查看。</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">root@localhost </span><span style="color:#89DDFF;">~]</span><span style="color:#A6ACCD;"># docker network ls</span></span>
<span class="line"><span style="color:#FFCB6B;">NETWORK</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">ID</span><span style="color:#A6ACCD;">          </span><span style="color:#C3E88D;">NAME</span><span style="color:#A6ACCD;">                </span><span style="color:#C3E88D;">DRIVER</span><span style="color:#A6ACCD;">              </span><span style="color:#C3E88D;">SCOPE</span></span>
<span class="line"><span style="color:#FFCB6B;">688d1970f72e</span><span style="color:#A6ACCD;">        </span><span style="color:#C3E88D;">bridge</span><span style="color:#A6ACCD;">              </span><span style="color:#C3E88D;">bridge</span><span style="color:#A6ACCD;">              </span><span style="color:#C3E88D;">local</span></span>
<span class="line"><span style="color:#FFCB6B;">885da101da7d</span><span style="color:#A6ACCD;">        </span><span style="color:#C3E88D;">host</span><span style="color:#A6ACCD;">                </span><span style="color:#C3E88D;">host</span><span style="color:#A6ACCD;">                </span><span style="color:#C3E88D;">local</span></span>
<span class="line"><span style="color:#FFCB6B;">f4f1b3cf1b7f</span><span style="color:#A6ACCD;">        </span><span style="color:#C3E88D;">none</span><span style="color:#A6ACCD;">                </span><span style="color:#C3E88D;">null</span><span style="color:#A6ACCD;">                </span><span style="color:#C3E88D;">local</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="https://pic2.zhimg.com/80/v2-a1bcf59f6b7731dfe355a28d29bf2f29_720w.webp" alt="network"></p><h2 id="bridge网络模型" tabindex="-1">bridge网络模型 <a class="header-anchor" href="#bridge网络模型" aria-label="Permalink to &quot;bridge网络模型&quot;">​</a></h2><p>在该模式中，Docker 守护进程创建了一个虚拟以太网桥 docker0，新建的容器会自动桥接到这个接口，附加在其上的任何网卡之间都能自动转发数据包。</p><p>默认情况下，守护进程会创建一对对等虚拟设备接口 veth pair，将其中一个接口设置为容器的 eth0 接口（容器的网卡），另一个接口放置在宿主机的命名空间中，以类似 vethxxx 这样的名字命名，从而将宿主机上的所有容器都连接到这个内部网络上。</p><p>比如我运行一个基于 busybox 镜像构建的容器 bbox01，查看 ip addr：</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>busybox 被称为嵌入式 Linux 的瑞士军刀，整合了很多小的 unix 下的通用功能到一个小的可执行文件中。</p></div><h2 id="网段冲突" tabindex="-1">网段冲突 <a class="header-anchor" href="#网段冲突" aria-label="Permalink to &quot;网段冲突&quot;">​</a></h2><p>docker安装以后会在主机上创建一个虚拟网卡-docker0，而我们启动的容器host网络以外，其他的都是通过docker0这个虚拟网卡经过物理网卡与外部通信的。这个虚拟网卡本身会有一个网段，一般是<code>172.17.x.x</code>，所以问题就明确了，因为docker0占用了这个网段，导致主机无法访问真是的网段机器。</p><p>私网地址是：</p><ul><li>A类地址：10.0.0.0～10.255.255.255</li><li>B类地址：172.16.0.0 ～172.31.255.255</li><li>C类地址：192.168.0.0～192.168.255.255</li></ul><p>注意局域网段如果是172.16～172.31，需要设置docker-compose子网</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">networks:</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">proxy:</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">ipam:</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#FFCB6B;">config:</span></span>
<span class="line"><span style="color:#A6ACCD;">      </span><span style="color:#FFCB6B;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">subnet:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">172.30</span><span style="color:#C3E88D;">.20.0/24</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>networks的参数ipam即网络管理，其下还有driver参数即指定使用的网络模式，以及config配置参数（比如配置子网等）。</p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">mynetwork1:</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">ipam:</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">driver:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">bridge</span></span>
<span class="line"><span style="color:#FFCB6B;">mynetwork2:</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">ipam:</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">driver:</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">default</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">config:</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#FFCB6B;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#C3E88D;">subnet:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">172.16</span><span style="color:#C3E88D;">.238.0/24</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div>`,19),o=[p];function r(c,t,i,C,d,b){return a(),n("div",null,o)}const A=s(e,[["render",r]]);export{D as __pageData,A as default};
