import{_ as s,v as a,b as n,R as l}from"./chunks/framework.caa0fbaf.js";const C=JSON.parse('{"title":"==运算符类型转换","description":"","frontmatter":{},"headers":[],"relativePath":"1-前端开发/2-JavaScript/7-==运算符类型转换.md","filePath":"1-前端开发/2-JavaScript/7-==运算符类型转换.md","lastUpdated":1697631288000}'),e={name:"1-前端开发/2-JavaScript/7-==运算符类型转换.md"},o=l(`<h1 id="运算符类型转换" tabindex="-1">==运算符类型转换 <a class="header-anchor" href="#运算符类型转换" aria-label="Permalink to &quot;==运算符类型转换&quot;">​</a></h1><p><code>相等运算符（==）</code>检查其两个操作数是否相等，返回一个布尔值结果。与<code>严格相等运算符（===）</code>不同，它会比较不同类型的操作数，并尝试强制类型转换。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Expected output: true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hello</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Expected output: true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Expected output: true</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// Expected output: true</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="同类型" tabindex="-1">同类型 <a class="header-anchor" href="#同类型" aria-label="Permalink to &quot;同类型&quot;">​</a></h2><p>如果操作数具有相同的类型，则按如下方式进行比较：</p><ol><li>对象（Object）：仅当两个操作数引用同一个对象时返回 true。</li><li>字符串（String）：只有当两个操作数具有相同的字符且顺序相同时才返回 true。</li><li>数值（Number）：如果两个操作数的值相同，则返回 true。+0 和 -0 被视为相同的值。如果任何一个操作数是 NaN，返回 false；所以，NaN 永远不等于 NaN。</li><li>布尔值（Boolean）：仅当操作数都为 true 或都为 false 时返回 true。</li><li>大整形（BigInt）：仅当两个操作数值相同时返回 true。</li><li>符号（Symbol）：仅当两个操作数引用相同的符号时返回 true。</li></ol><h2 id="不同类型" tabindex="-1">不同类型 <a class="header-anchor" href="#不同类型" aria-label="Permalink to &quot;不同类型&quot;">​</a></h2><h3 id="_1-null和undefined" tabindex="-1">1.null和undefined <a class="header-anchor" href="#_1-null和undefined" aria-label="Permalink to &quot;1.null和undefined&quot;">​</a></h3><p>如果其中一个操作数为 null 或 undefined，另一个操作数也必须为 null 或 undefined 以返回 true。<code>否则</code>返回 false。</p><h3 id="_2-object和基本类型" tabindex="-1">2.Object和基本类型 <a class="header-anchor" href="#_2-object和基本类型" aria-label="Permalink to &quot;2.Object和基本类型&quot;">​</a></h3><p>如果其中一个操作数是对象，另一个是基本类型，按此顺序使用对象的 @@toPrimitive()（以 &quot;default&quot; 作为提示），valueOf() 和 toString() 方法将对象转换为<code>基本类型</code>。（这个基本类型转换与<code>相加</code>中使用的转换相同。）</p><p>双方都是基本类型（但不是同类型），则进行下一步。</p><h3 id="_3-不同类型的基本类型" tabindex="-1">3.不同类型的基本类型 <a class="header-anchor" href="#_3-不同类型的基本类型" aria-label="Permalink to &quot;3.不同类型的基本类型&quot;">​</a></h3><ol><li>如果其中一个操作数是 Symbol 而另一个不是，返回 false。</li><li>如果其中一个操作数是<code>布尔型</code>而另一个不是，则将布尔型转换为<code>数字</code>：true 转换为 1，false 转换为 0。然后再次松散地比较两个操作数。</li><li>Number to String：使用与 Number() 构造函数相同的算法将字符串转换为<code>数字</code>。转换失败将导致 NaN，这将保证相等是 false。</li><li>Number to BigInt：按数值进行比较。如果数值为 ±∞ 或 NaN，返回 false。</li><li>String to BigInt：使用与 BigInt() 构造函数相同的算法将<code>字符串转换为 BigInt</code>。如果转换失败，返回 false。</li></ol><p>该运算符与严格相等（===）运算符之间最显著的区别是，严格相等运算符不尝试类型转换。相反，严格相等运算符总是认为不同类型的操作数是不同的。严格相等运算符本质上只执行第 1 步，然后对所有其他情况返回 false。</p><p>上面的算法有一个“故意违反”：如果其中一个操作数是 document.all，则它被视为 undefined。这意味着 document.all == null 是 true，但 document.all === undefined &amp;&amp; document.all === null 是 false。</p>`,16),p=[o];function t(r,c,i,d,u,y){return a(),n("div",null,p)}const b=s(e,[["render",t]]);export{C as __pageData,b as default};
